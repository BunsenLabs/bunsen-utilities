#!/bin/bash
#
#    bl-obthemes: script to save or restore various GUI theme settings
#    Copyright (C) 2015-2020 damo    <damo@bunsenlabs.org>
#                  2018-2023 John Crawley <john@bunsenlabs.org>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#
# Save options are for  Conky(s)
#                       Tint2(s)
#                       Openbox theme
#                       GTK theme
#                       Background (uses Nitrogen or feh, depending which
#                                   has the newer saved bg config file)
#                       Alt Menu (dmenu)
#                       Lightdm login gtk greeter
#                       X configs (.bashrc, .Xresources)
#                       Terminal emulator config
#
# Paths are assumed to be BunsenLabs defaults
#
# A Screenshot is saved (Windows are hidden briefly so the image
#                        is the bare desktop, with any Tint2s
#                        or Conkys which are running, and a representive
#                        menu and window open)
#
# A time-stamped backup of rc.xml is saved "just in case".
#
# USER VARIABLE: xdotool is used to move the mouse pointer, and assumes the
# root-menu is shown with "Super + Space" keys, and the right mouse button is
# set for "r-click". If you have set these to something else, then edit the
# "MENUMODIFIER" variable and "MOUSECMD" array.
# Set the variable "KEYDOWN" to where "Preferences" is in the root-menu (or
# anything else you might want displayed).
# The image viewer is set to be "bl-image-viewer". Edit the "IMGCMD" variable
# to change this.
#
# WARNING: Conkys in non-default directories are saved, but
# will not be seen when running the bl conky manager.
#
########################################################################
#
# KNOWN ISSUES:
# Virtualbox does not allow the guest to move the host mouse cursor, using xdotool,
# so the screenshot may produce an incorrect theme displayed and/or poor positioning.
# A workaround is to move the cursor to some free space, and use the "Enter" key in the
# "Configurations to be saved:" dialog.
#

HELP='bl-obthemes is a script to save or restore gui theme settings

Usage:  bl-obthemes [-h|--help][-v|--verbose]

Optional arguments:
        -h, --help      show this message
        -v, -d, --verbose, --debug   describe actions being performed
No other CLI options are supported.

Save options:
            Conky(s)

            Tint2(s)

            Openbox theme

            GTK theme

            Background
            (uses Nitrogen or feh, depending which has the newer saved bg config file)

            Alt Menu (dmenu)

            Lightdm login gtk greeter

            X configs (.bashrc, .Xresources)

            Terminal emulator config (if available)

            Compositor config (if available)

            jgmenu theming (if available)

Paths are assumed to be BunsenLabs defaults.

A Screenshot is saved
                    (Windows are hidden briefly so the image
                    is the bare desktop, with any Tint2s
                    or Conkys which are running, and a representive
                    menu and window open.)

A time-stamped backup of rc.xml is saved "just in case".

Configuration:

 USER VARIABLE: xdotool is used to move the mouse pointer, and assumes the
 root-menu is shown with "Super + Space" keys, and the right mouse button is
 set for "r-click". If you have set these to something else, then edit the
 "MENUMODIFIER" variable and "MOUSECMD" array.
 Set the variable "KEYDOWN" to where "Preferences" is in the root-menu (or
 anything else you might want displayed).
 The image viewer is set to be "bl-image-viewer". Edit the "IMGCMD" variable
 to change this.

WARNING:
 Conkys in non-default directories are saved, but will not be seen
 when running the bl conky manager.

KNOWN ISSUES:
 Virtualbox does not allow the guest to move the host mouse cursor,
 using xdotool, so the screenshot may produce an incorrect theme displayed
 and/or poor positioning.
 A workaround is to move the cursor to some free space, and use
 the "Enter" key in the "Configurations to be saved:" dialog.
'

debug() { : ;}
DEBUG_FLAG=0 # will be interpreted numerically, as boolean
for i in "$@"
do
    case "$i" in
    -h|--help)
        echo "$HELP"
        exit 0
        ;;
    -v|-d|--verbose|--debug)
        debug() {
            echo -e "$*"
        }
        DEBUG_FLAG=1
        ;;
    esac
done

######################### VARIABLES ####################################
# ( with some exceptions, GLOBAL variable names are uppercase, local in functions are lowercase )

### USER SETTINGS FOR THIS SCRIPT
IMGCMD="bl-image-viewer"    # application command to view screenshot
MENUMODIFIER="super+space"  # keybind for show root-menu (not used in standard BunsenLabs sessions)
KEYDOWN=10                  # adjust this for where "Preferences" is in the menu
MOUSECMD=(click 3)          # mouse r-click

### GLOBALS
USRCONFIGPATH="$HOME/.config/blob"
SYSCONFIGPATH="/usr/share/bunsen/utilities/blob"
CURSESSFILE="$USRCONFIGPATH/current"

### USER CONFIG VARIABLES TO BE SAVED AND RESTORED
OBPATH="$HOME/.config/openbox"
RCFILE="$OBPATH/bl-rc.xml" # NB now using the new BunsenLabs file name
OLDRCFILE="$OBPATH/rc.xml"
GTK2=".gtkrc-2.0"
GTK2MINE=".gtkrc-2.0.mine"
GTK3=".config/gtk-3.0"
GTK3x=".config/xfce4/xfconf/xfce-perchannel-xml/xfce4-notifyd.xml"
FEHFILE=".fehbg"
NITROFILE=".config/nitrogen/bg-saved.cfg"
DMENU=".config/dmenu/dmenu-bind.sh"
XFILE=".Xresources"
BASHRC=".bashrc"
#TERMFILE='' # now termfile is set dynamically by checkTerm() in saveSettings()
COMPFILE=".config/picom.conf"
OLDCOMPFILE=".config/compton.conf"
JGMENURC=".config/jgmenu/jgmenurc" # jgmenu theming, not menu content

CONKYPATH=".config/conky"
TINTPATH=".config/tint2"
# These will not be saved as-is,
# but generated from the running conky/tint2 processes.
# Saved files will be restored.
CONKYSESSION="$CONKYPATH/conky-sessionfile"
TINTSESSION="$TINTPATH/tint2-sessionfile"

### SYSTEM CONFIG VARIABLES TO BE SAVED AND RESTORED
LDMDIR="/etc/lightdm"
LDM="lightdm-gtk-greeter.conf"

### END CONFIGS VARIABLES

# current running openbox session, tested when script starts
# usually set to "bunsenlabs", but "openbox" for a vanilla openbox session
OBSESSION=''

# used by forkncheck()
FORKWAIT='0.3' # time to wait before checking if a forked process is still running
# use any value which is  accepted by 'sleep'

# used when translating paths in system preset themes
HOME_MARKER='%USERHOME%'

# packages needed for particular GTK themes
declare -A theme_pkgs=(
[Beam]=bunsen-themes
[Beam-HiDPI]=bunsen-themes
[BL-Fever_Room]=bunsen-themes
[BL-Lithium]=bunsen-themes
[BL-Lithium-light]=bunsen-themes
[Bunsen-He-flatish]=bunsen-themes
[Yeti]=bunsen-themes
[Yeti-Lith]=bunsen-themes
)

# packages needed for particular icon themes
declare -A icon_pkgs=(
[Faenza-Dark-Bunsen]='bunsen-faenza-icon-theme'
[Faenza-Bunsen]='bunsen-faenza-icon-theme'
[Paper-Bunsen]='bunsen-paper-icon-theme'
[Papirus-Bunsen-grey]='bunsen-papirus-icon-theme'
[Papirus-Bunsen-bluegrey]='bunsen-papirus-icon-theme'
[Papirus-Bunsen-Dark-grey]='bunsen-papirus-icon-theme'
[Papirus-Bunsen-Dark-bluegrey]='bunsen-papirus-icon-theme'
[Adwaita]='adwaita-icon-theme'
)

###

THEMEPATH_1="$HOME/.themes"
THEMEPATH_2="$HOME/.local/share/themes"
THEMEPATH_3="/usr/share/themes"
THEMEPATH_4="/usr/local/share/themes"
gtkPaths=("$THEMEPATH_1" "$THEMEPATH_2" "$THEMEPATH_3" "$THEMEPATH_4")

ICONPATH_1="$HOME/.icons"
ICONPATH_2="$HOME/.local/share/icons"
ICONPATH_3="/usr/share/icons"
ICONPATH_4="/usr/local/share/icons"
iconPaths=("$ICONPATH_1" "$ICONPATH_2" "$ICONPATH_3" "$ICONPATH_4")


### DIALOG VARIABLES
TITLE="BLOB Themes Manager"
ICON="distributor-logo-bunsenlabs"
yad_args=( '--center'  '--borders=20' "--window-icon=$ICON" )
popup_args=( "${yad_args[@]}" "--title=$TITLE" '--undecorated' '--fixed' )
OK="--button=OK:0"
CANCEL="--button=gtk-cancel:1"
EXIT="--button=gtk-quit:1"
CLOSE="--button=gtk-close:1"
HLPBTN="--button=_Help:10"

## USER READABLE LABELS
PICKOB="OB theme"
PICKGTK="GTK theme"
PICKICONS="Icon theme"
PICKBG="Background Wallpaper"
PICKCONKY="Conky"
PICKTINT="Tint2"
PICKDMENU="dmenu (Alt menu)"
PICKLDM="Lightdm Login theme"
#PICKEXIT="Exit dialog theme" # bl-exit no longer has separate themes
#PICKTERM='' # now not global, pickterm is from checkTerm(), local in saveSettings()
PICKX="X configs"
PICKBASH="Bash configs"
PICKCOMP="Compositor"
PICKJGMENU="jgmenu theming"

### END DIALOG VARIABLES

####################### END VARIABLES ##################################


######################### FUNCTIONS ####################################

### DIALOG FUNCTIONS

# yad displays cancel & OK buttons by default
# --button=* arguments will overrule this default

# arbitary options (eg --entry) can be passed *after* the text
yad_prompt() {
    yad "${popup_args[@]}" --text="$1" --width=300 "${@:2}"
}

yad_question() {
    yad "${popup_args[@]}" --text="$1" \
    --image="dialog-question" --width=300 "${@:2}"
}

yad_warning() {
    yad "${popup_args[@]}" --text="$1" \
    --image="dialog-warning" --width=300 --button=gtk-close:0
}

yad_warning_option() {
    yad "${popup_args[@]}" --text="$1" \
    --image="dialog-warning" --width=300 --button="Continue anyway:0" "$EXIT"
}

yad_fatal_error() {
    yad "${popup_args[@]}" --text="$1" \
    --image="dialog-error" --width=300 "$EXIT"
}

### END DIALOG FUNCTIONS

# Trap will pass the line number where the error ocurred as $1,
# and the command run on that line as $2.
# This should not be needed once error handling is all done separately.
trap_error(){
    local msg="An error ocurred on line ${1}, running function '${2}', command '${3}'.\nPlease consider reporting this to the developers."
    echo -e "$0: $msg" >&2
    if yad_warning_option "$msg"
    then
        debug "Continuing despite restore error."
    else
        exit 1
    fi
}

# Usage: createFlag filename
# Currently used in Intro()
# to record if "About" window has been shown.
createFlag() {
    mkdir -p "$HOME/.config/bunsen"
    touch "$HOME/.config/bunsen/$1"
}

# This is run at the start.
# OBSESSION global used in getScrot()
firstChecks() {
    # Do not run as root (Bad Things may happen).
    if [[ $( id -u ) -eq 0 ]]; then
        echo $"$0: Error: This script should not be run by root." >&2
        exit 1
    fi

    # Test if openbox is running, and with what session file.
    obline=$(pgrep -ax -u "$USER" openbox) || {
        yad_fatal_error "This script can only be used with openbox."
        exit 1
    }
    [[ $obline =~ --startup[[:blank:]]+([^[:blank:]]+) ]] || {
        yad_fatal_error "Openbox was started without a startup file."
        exit 1
    }
    case ${BASH_REMATCH[1]} in
    */bunsen-autostart)
        debug "  BunsenLabs session detected."
        OBSESSION=bunsenlabs
        ;;
    */openbox-autostart)
        debug "  Vanilla Openbox session detected."
        yad_warning "BunsenLabs uses Openbox with some custom config files,
    but we have detected that you are running a standard Openbox session.
    Some things might not work as expected without editing this script.
    You can copy /usr/bin/bl-obthemes to ~/bin/ and edit it there.
    At least, check if MENUMODIFIER and KEYDOWN at the top of the file
    are set appropriately to trigger the menu display for screenshots." "$OK" "$EXIT" || exit 1
        OBSESSION=openbox
        ;;
    *)
        yad_fatal_error "Unable to determine the current openbox session."
        exit 1
        ;;
    esac
}

# Fork a process to the background, return 1 if it exits soon.
# Do not use with processes like conky, which can fork themselves to a new pid.
# Global $FORKWAIT is time to wait before checking if process is still running.
# Arguments are the command to run.
forkncheck() {
    local pid
    set -m
    "$@" >/dev/null 2>&1 & pid=$!
    disown
    set +m
    sleep "$FORKWAIT" || return 1 # check for bad syntax in $FORKWAIT
    kill -0 "$pid" >/dev/null 2>&1 && return 0
    return 1 # process is not running
}

# needed if a BLOB directory was last generated on BL lithium before Oct 2019
# Drop this in BL Carbon?
function upgradeBlobs(){
    moveFile(){ # $1 is file, $2 is target dir
        [[ -f "$2/${1##*/}" ]] && return 0
        [[ -f "$1" ]] || {
            echo "$0: Upgrading ${i}: WARNING Cannot move file ${1}, it does not exist" >&2
            return 1
        }
        mkdir -p "$2"
        mv "$1" "$2" || exit
    }
    moveDir(){
        [[ -d "$2/${1##*/}" ]] && return 0
        [[ -d "$1" ]] || {
            echo "$0: Upgrading ${i}: WARNING Cannot move directory ${1}, it does not exist" >&2
            return 1
        }
        mkdir -p "$2"
        mv "$1" "$2" || exit
    }
    # checks tint sessionfile, updates filenames to new format
    # tint2 config files will have been renamed from tint2rc-something to something.tint2rc
    # variable VAL is rewritten
    check_tintsess() {
        debug "Checking ${i}/user/$TINTPATH for tint2 file names..."
        local t2file t2name newt2name
        local -a tintsession
        VAL=''
        mapfile -t tintsession < "$i/user/$TINTSESSION"
        for t2file in "${tintsession[@]}"
        do
            [[ -n $t2file ]] || continue
            t2name=${t2file##*/}
            [[ $t2name = *'.tint2rc' || $t2name = tint2rc ]] && {
                VAL+=${t2file};
                continue # already using new name style
            }
            newt2name=${t2name#tint2rc-}.tint2rc
            if [[ -f $i/user/$TINTPATH/$t2name ]] # have local copy, rename
            then
                debug "Renaming $t2name to $newt2name in ${i}/user/$TINTPATH"
                mv "${i}/user/$TINTPATH/$t2name" "${i}/user/$TINTPATH/$newt2name" || {
                    echo "$0: Upgrading ${i}: WARNING Cannot rename $i/user/$TINTPATH/$t2name" >&2
                    VAL+=${t2file};
                }
                VAL+=$HOME/$TINTPATH/${newt2name};
            else
                [[ -f $HOME/$TINTPATH/$newt2name ]] && { # user file already exists with new name, copy it locally
                    debug "Copying $HOME/$TINTPATH/$newt2name to ${i}/user/$TINTPATH/"
                    cp "$HOME/$TINTPATH/${newt2name}" "${i}/user/$TINTPATH/" || echo "$0: Upgrading ${i}: WARNING Cannot copy $HOME/$TINTPATH/$newt2name to $i/user/$TINTPATH/" >&2
                    VAL+=$HOME/$TINTPATH/${newt2name};
                    continue
                }
                [[ -f $t2file ]] && { # user file with current oldstyle name exists, copy it locally with new name
                    debug "Copying $t2file to ${i}/user/$TINTPATH as $newt2name"
                    cp "$t2file" "${i}/user/$TINTPATH/$newt2name" || {
                        echo "$0: Upgrading ${i}: WARNING Cannot copy $t2file to $i/user/$TINTPATH/" >&2
                        VAL+=${t2file};
                    }
                    VAL+=$HOME/$TINTPATH/${newt2name};
                    continue
                }
                echo "$0: Upgrading ${i}: WARNING Cannot find tint2 config file $t2file referred to in $i/user/$TINTSESSION" >&2
                VAL+=${t2file};
            fi
        done
    }
    for i in "$USRCONFIGPATH"/*; do
        [[ -d $i ]] || continue
        mkdir -p "$i/user"
        local themename=${i##*/}
        moveFile "$USRCONFIGPATH/${themename}.jpg" "$i"
        :> "$i/newsettings"
        while read -r TAG VAL; do
            case "$TAG" in
                "[TINT2]"       )   [[ -f "$i/user/$TINTSESSION" ]] || {
                                        mkdir -p "$i/user/${TINTSESSION%/*}"
                                        printf '%s\n' "${VAL//;/$'\n'}" > "$i/user/$TINTSESSION"
                                    }
                                    check_tintsess # VAL is rewritten
                                    printf '%s\n' "${VAL//;/$'\n'}" > "$i/user/$TINTSESSION" # rewrite session file with new filenames
                                    printf '%s %s\n' "$TAG" "$VAL" >> "$i/newsettings"
                                    ;;
                "[CONKY]"       )   [[ -f "$i/user/$CONKYSESSION" ]] || {
                                        mkdir -p "$i/user/${CONKYSESSION%/*}"
                                        printf '%s\n' "${VAL//;/$'\n'}" > "$i/user/$CONKYSESSION"
                                    }
                                    printf '%s %s\n' "$TAG" "$VAL" >> "$i/newsettings"
                                    ;;
                "[ICONS]"       )   printf '%s %s\n' "$TAG" "$VAL" >> "$i/newsettings"
                                    ;;
                "[GTK]"         )   moveFile "$i/.gtkrc-2.0" "$i/user"
                                    moveFile "$i/.gtkrc-2.0.mine" "$i/user"
                                    moveFile "$i/xfce4-notifyd.xml" "$i/user/.config/xfce4/xfconf/xfce-perchannel-xml"
                                    moveDir "$i/gtk-3.0" "$i/user/.config"
                                    printf '%s %s\n' "$TAG" "$VAL" >> "$i/newsettings"
                                    ;;
                "[OBTHEME]"     )   printf '%s %s\n' "$TAG" "$VAL" >> "$i/newsettings"
                                    ;;
                "[BACKGROUND]"  )   if [[ $VAL = FEH ]];then
                                        moveFile "$i/.fehbg" "$i/user"
                                    else
                                        moveFile "$i/bg-saved.cfg" "$i/user/.config/nitrogen"
                                    fi
                                    printf '%s %s\n' "$TAG" "$VAL" >> "$i/newsettings"
                                    ;;
                "[DMENU]"       )   moveFile "$i/dmenu-bind.sh" "$i/user/.config/dmenu" && {
                                        printf '%s %s\n' "$TAG" "$VAL" >> "$i/newsettings"
                                    }
                                    ;;
                "[LIGHTDM]"     )   printf '%s %s\n' "$TAG" "$VAL" >> "$i/newsettings"
                                    ;;
                "[EXITRC]"      )   printf '%s %s\n' "$TAG" "$VAL" >> "$i/newsettings"
                                    ;;
                                    # split [XFILES] into two tags
                "[XFILES]"      )   moveFile "$i/$XFILE" "$i/user" && {
                                        printf '%s\n' '[XFILE]' >> "$i/newsettings"
                                    }
                                    moveFile "$i/$BASHRC" "$i/user" && {
                                        printf '%s\n' '[BASHRC]' >> "$i/newsettings"
                                    }
                                    ;;
                "[TERMINATOR]"  )   moveFile "$i/config" "$i/user/.config/terminator" && {
                                        printf '%s %s\n' '[Terminator]' '.config/terminator/config' >> "$i/newsettings"
                                    }
                                    ;;
                '['*']'         )   printf '%s %s\n' "$TAG" "$VAL" >> "$i/newsettings"
                                    ;;
                *               )   echo -e "Upgrading ${i}: ${TAG}:  Unknown value!" >&2
                                    continue
                                    ;;
            esac
        done < "$i/settings.cfg"
        mv -f "$i/newsettings" "$i/settings.cfg"
    done
}

# Kill only with exact match, and only if process belongs to executor.
# Returns success even if process is not running.
# Usage: safeKill <processname>
function safeKill() {
    local procname
    procname=$1
    debug "killing $procname"
    pgrep -x -u "$USER" "$procname" >/dev/null || {
        debug "${procname}: no process running"
        return 0
    }
    pkill -x -u "$USER" "$procname" || {
        debug "WARNING failed to kill $procname"
        return 1
    }
}

# $1 is path to keyfile (eg gtk3 settings.ini)
# global associative array KEYS will be generated
parseKeyfile(){
    [[ -f $1 ]] || { echo "$1 is not a file." >&2; return 1;}
    unset KEYS
    declare -Ag KEYS
    local entry_regex line key value
    entry_regex="^[[:blank:]]*([[:alnum:]_][[:alnum:]_-]*)[[:blank:]]*=[[:blank:]]*('[^']+'|\"[^\"]+\"|[^#[:blank:]]+([[:blank:]]+[^#[:blank:]]+)*)[[:blank:]]*(#.*)*$"
    while read -r line
    do
        [[ -n $line ]] || continue
        [[ $line =~ $entry_regex ]] || continue
        key=${BASH_REMATCH[1]}
        value=${BASH_REMATCH[2]}
        case $value in # strip quotes
        \'*\')
            value=${value#\'}; value=${value%\'};;
        \"*\")
            value=${value#\"}; value=${value%\"};;
        esac
        KEYS["${key}"]="${value}"
    done < "$1"
    [[ -v KEYS[@] ]] || { echo "$0: parsing file ${1}: global array KEYS is empty" >&2; return 1;}
}

# This function is used when restoring icons without GTK or vice versa.
# It's placed here because it's related to parseKeyfile.
# editKeyfile [--gtk2] file name=value [name2=value2...]
# --gtk2 puts quotes around written string values
editKeyfile(){
    local type=gtk3 file name value sed_pattern sed_replace sed_args
    [[ $1 = '--gtk2' ]] && {
        type=gtk2
        shift
    }
    [[ -f $1 ]] || { echo "$1 is not a file." >&2; return 1;}
    file=$1
    shift
    parseKeyfile "$file" # generates KEYS for the two checks
    boolean_enum_re='^([01]|GTK_[[:upper:]_]*)$' # in GTK2 gtkrc files these values are not quoted
    sed_args=()
    while [[ $1 ]]; do
        unset name value sed_pattern sed_replace
        name="${1%%=*}"
        value="${1#*=}"
        shift
        [[ -v KEYS["$name"] ]] || {
            echo "$0: config key $name does not exist" >&2
            return 1
        }
        [[ ${KEYS["$name"]} = "${value}" ]] && {
            debug "Key KEYS[$name] is already set to ${value}"
            continue
        }
        [[ $type = gtk2 ]] && {
            [[ $value =~ $boolean_enum_re ]] || { # quote strings for gtk2 file
                value="\"$value\""
            }
        }
        (( ${#sed_args[@]} == 0 )) && sed_args=("-ri")
        sed_pattern="^[[:blank:]]*${name}[[:blank:]]*=[[:blank:]]*('[^']+'|\"[^\"]+\"|[^#[:blank:]]+([[:blank:]]+[^#[:blank:]]+)*)[[:blank:]]*(#.*)*$"
        sed_replace+="${name}=${value}"
        sed_args+=("-e")
        sed_args+=("s/$sed_pattern/$sed_replace/")
    done
    (( ${#sed_args[@]} )) && sed "${sed_args[@]}" "$file" || { echo "$0: sed error" >&2; return 1;}
}


# sets globals NUMDIRS and CURRENTSESSION, inside intro() and UpdateDisplayDialog()
function getCurrent(){      # get name of currently set BLOB config
    local dirs
    NUMDIRS=0
    shopt -s nullglob
    dirs=( "$USRCONFIGPATH"/*/ "$SYSCONFIGPATH"/*/ )
    NUMDIRS=${#dirs[@]}
    shopt -u nullglob
    if (( NUMDIRS == 0 ));then
        if [[ -f $CURSESSFILE ]];then
            rm "$CURSESSFILE"
        fi
    elif (( NUMDIRS > 0 )) && [[ -f $CURSESSFILE ]];then
        CURRENTSESSION=$(< "$CURSESSFILE")
    fi
}

# pass --one-view-only to skip the intro window
# after first viewing
function Intro(){

    debug 'Welcome to BLOB!'

    getCurrent # generates globals NUMDIRS and CURRENTSESSION

    if [[ $1 = '--one-view-only' && -e $HOME/.config/bunsen/blob-intro-viewed ]] && (( NUMDIRS > 0 ));then
        displayBlobs
    else
        TXTINTRO='<big><b>BLOB: BunsenLabs GUI Themes Manager</b></big>


<b>Save or Restore settings for any or all of these:</b>

    Openbox theme
    GTK theme
    Conkys
    Tint2
    Desktop Background
    Alt Menu (dmenu)
    LightDM theme
    X configs (.bashrc, .Xresources)
    Terminal (if config file is known)
    Compositor (if config file exists)
    jgmenu (if config file exists)
    + Screenshot

'

        createFlag 'blob-intro-viewed'

        #  if blob/ is empty, then don't display "View Saved" option in Intro dialog
        if (( NUMDIRS > 0 ));then
            yad "${yad_args[@]}" "--text=$TXTINTRO" \
            --title="$TITLE" --borders=30 \
            --button="_Save Current Blob:0" --button="_View Saved Blobs:2" $HLPBTN $CLOSE

        else
            yad "${yad_args[@]}" "--text=$TXTINTRO" \
            --title="$TITLE" --borders=30 \
            --button="_Save Current Blob:0" $HLPBTN $CLOSE

        fi
        case $? in
            0)  saveNewBlob
                displayBlobs
                ;;
            1)  debug "CANCELLED..."
                exit 0
                ;;
            2)  displayBlobs
                ;;
            10) yad --button="OK":0 --center --window-icon=distributor-logo-bunsenlabs --text-info --title="The BLOB themes manager" --filename="/usr/share/bunsen/docs/helpfiles/helpfile-blob.txt" --width=900 --height=700 --fontname=Monospace
                Intro
                ;;
            *)  echo "RETURN ERROR" >&2
                exit 1
                ;;
        esac
    fi
}

####################### save functions #################################

# sets globals CONFIGDIR CONFIGDIR_BKP SETTINGS LISTMSG NEWNAME for storing new theme
function setName(){  # set name of collection, make dir and session settings file
    local msg msg2
    msg="  Configurations will be saved to a new directory in  \
    \n  $USRCONFIGPATH\n\n  Enter name of new collection...  "
    msg2="  No file specified for new saved session.\n\n  Try again?"
    local del time txt
    del=0
    while true;do  # loop dialog if nothing is selected
        NEWNAME=$( yad_prompt "$msg" --entry )
        if (( $? == 1 )) ;then # Cancel was selected
            return 1
        elif [[ ! $NEWNAME ]] ;then     # entry was empty
            debug "\n  No name entered for new collection!"
            yad_question "$msg2"
            RET=$?
            if (( RET == 0 ));then
                continue
            else
                return 1
            fi
        else
            NEWNAME=${NEWNAME// /_}    # replace any spaces in dir name
            CONFIGDIR="$USRCONFIGPATH/$NEWNAME"
            CONFIGDIR_BKP="${CONFIGDIR}.bkp"
            if [[ -d $CONFIGDIR ]];then
                debug "\n  $CONFIGDIR already exists"
                if yad_question "Overwrite existing saved session?"
                then
                    mv "$CONFIGDIR" "$CONFIGDIR_BKP" # && mkdir -p "$CONFIGDIR"
                    del=1
                else
                    continue
                fi
            fi
            mkdir -p "$CONFIGDIR" || return 1
            SETTINGS="$CONFIGDIR/settings.cfg"
            LISTMSG="$CONFIGDIR/LISTMSG.txt"
            :> "$SETTINGS"
            :> "$LISTMSG"
            break
        fi
    done
    time=$(date)
    if (( del == 1 ));then
        txt="  (Existing session overwritten)"
    else
        txt=""
    fi
    debug "\n  Configuration will be saved as: $NEWNAME$txt"

#     store list in listfile
    echo -e "<b>Configuration name: $NEWNAME</b>\t$txt\nSaved at $time\n" >> "$LISTMSG"
}

# $1 [$2...] are relative paths passed from save functions
# Save user config file to corresponding directory in $CONFIGDIR/user.
# CONFIGDIR is global set by setName()
function saveFiles(){
    local i src_file target_file
    for i in "$@"
    do
        src_file="$HOME/$i"
        target_file="$CONFIGDIR/user/$i"
        saveFileAbs "$src_file" "$target_file" || {
            echo "$0: Failed to save $src_file" >&2
            return 1
        }
    done
}


# $1 and $2 are absolute source and target filepaths
# target should be inside newly created CONFIGDIR
# if source is directory it is saved recursively
function saveFileAbs(){
    local src_file target_file target_dir
    src_file="$1"
    target_file="$2"
    target_dir="${target_file%/*}"
    [[ $target_file = $CONFIGDIR/* ]] || {
        echo "$0: Target is not inside $CONFIGDIR" >&2
        return 1
    }
    [[ -r $src_file ]] || {
        echo "$0: Cannot read source file $src_file" >&2
        return 1
    }
    mkdir -p "$target_dir" || return 1
    if [[ -d $src_file ]];then
        cp -r "$src_file" "$target_file" || return 1
        debug "directory $src_file and contents saved to $target_dir"
    else
        cp "$src_file" "$target_file" || return 1
        debug "file $src_file saved to $target_dir"
    fi
}

# CONFIGDIR is global set by setName()
function saveDconf(){ # passed dconf directory as #1 and name of app (for dumpfile) as $2
    local dconfdir appname dumpfile
    dconfdir=$1
    appname=$2
    mkdir -p "$CONFIGDIR/dconf" || return 1
    dumpfile="$CONFIGDIR/dconf/${appname// /_}" # remove any spaces from name
    dconf dump "$dconfdir" > "$dumpfile" || return 1
    if [[ -s $dumpfile ]]
    then
        debug "Saved dconf $dconfdir to $dumpfile"
    elif [[ -e $dumpfile ]]
    then
        debug "dconf $dconfdir is default, created empty file $dumpfile"
    else
        "$0: failed to create $dumpfile" >&2
        return 1
    fi
}

# prints newest of files in "$@", returns 1 if no file is passed
# used in getBG
function newest()  {
    [[ -n $1 ]] || return 1
    local i candidate
    for i in "$@"
    do
        [[ -f $i ]] || continue
        if [[ -n $candidate ]]
        then
            [[ $i -nt $candidate ]] && candidate="$i"
        else
            candidate="$i"
        fi
    done
    [[ -n $candidate ]] || return 1
    printf '%s' "$candidate"
}

function getBg(){    # Find if feh, nitrogen or other was used. Save config file(s) if possible.
    local bgset daemon_bgsetters
    daemon_bgsetters=(xfdesktop) # If any of these are running, cannot use nitrogen or feh.

    bgset="$( newest "$HOME/$NITROFILE" "$HOME/$FEHFILE" )" || {
        echo "$0:  No nitrogen or feh files found" >&2
        bgset="None"
    }

    for i in "${daemon_bgsetters[@]}"
    do
        pgrep -x "$i" -u "$USER" && {
            echo "$0: unsupported background setter $i is running" >&2
            bgset="None"
        }
    done

    debug "\n  Background to be set with $bgset"
    case "$bgset" in
        FEH     )   getFeh || {
                        echo "$0: Failed to save feh config." >&2
                        return 1
                    }
                    ;;
        NITROGEN)   getNitrogen || {
                        echo "$0: Failed to save nitrogen config." >&2
                        return 1
                    }
                    ;;
        None    )   echo "$0: No background-setting application found" >&2
                    echo -e "Background cannot be set with nitrogen or feh\n" >> "$LISTMSG"
                    ;;
    esac
    echo "[BACKGROUND] $bgset" >> "$SETTINGS"
}

# FEHFILE is config global
# CONFIGDIR is global set by setName()
function getFeh(){    # get Feh saved backgrounds
    local ffile="$CONFIGDIR/user/$FEHFILE"
    saveFiles "$FEHFILE" || {
        echo "$0: Failed to save feh configs file $FEHFILE" >&2
        return 1
    }
    if [[ -f $ffile ]];then
        local bg=""
        # get fields between single quotes
        while read -r line;do
            bg="$bg$line;\n\t"
        done < <(grep -o "'[^']*'" "$ffile" | sed "s/'//g" 2>/dev/null)
        debug "\n  Backgrounds set with Feh, using:\t$CONFIGDIR/user/$FEHFILE"
        debug "\t$bg"
        echo -e "Background set with feh:\n\t$bg" >> "$LISTMSG"
    else
        echo "$0:  $ffile not found" >&2
    fi
}

# NITROFILE is config global
# CONFIGDIR is global set by setName()
function getNitrogen(){  # get Nitrogen saved backgrounds
    local nfile="$CONFIGDIR/user/$NITROFILE"
    saveFiles "$NITROFILE" || {
        echo "$0: Failed to save nitrogen configs file $NITROFILE" >&2
        return 1
    }
    if [[ -f $nfile ]];then
        local bg=""
        while read -r line;do
            [[ $line = 'file='* ]] || continue
            bg="$bg${line#file=};\n\t"
        done < "$nfile"
        debug "\n  Backgrounds set with Nitrogen, using:\t$CONFIGDIR/user/$NITROFILE"
        debug "\t$bg"
        echo -e "Background set with nitrogen:\n\t$bg" >> "$LISTMSG"
    else
        echo "$0:  $nfile not found" >&2
    fi
}

# generates command array idCmd from window id (hex or decimal)
# WARNING WM_COMMAND is deprecated: https://www.x.org/releases/X11R7.6/doc/xorg-docs/specs/ICCCM/icccm.html#obsolete_session_manager_conventions
# TODO switch to using mapfile with pids and /proc/${pid}/cmdline as in getTint()
# but, need to handle conkys on specific desktops.

# Usage: getIdCmd <id>
# called in getConky() where idCmd is local array variable
# NOTE: this works with conky windows, but not with tint2 which provides no WM_COMMAND data.
function getIdCmd(){
    local wmc del s
    wmc=$(xprop -id "$1"  WM_COMMAND)
    wmc=${wmc#*\"} # strip first & last quotes & everything outside
    wmc=${wmc%\"*}
    wmc=${wmc//\\\"/\"} # unescape any inner quotes
    del='", "' # delimiter
    s=${wmc}${del}
    idCmd=()
    while [[ -n $s ]]; do
        idCmd+=("${s%%${del}*}")
        s=${s#*${del}}
    done
}

# extracts path to conky config file from idCmd array generated by getIdCmd()
# conkyfile is local to getConky()
function getCfile(){
    local i
    conkyfile=''
    for i in "${!idCmd[@]}"; do
        [[ ${idCmd[i]} = '-c' ]] && { conkyfile="${idCmd[i+1]}"; break;}
        [[ ${idCmd[i]} = '--config='* ]] && { conkyfile="${idCmd[i]#--config=}"; break;}
    done
}

# trim /home/<user>/ from filepath
# reject absolute path elsewhere in system
# pass relative path as-is, assume relative to ~/
userFilepath(){
    local file=$1
    if [[ $file = "$HOME"/* ]]
    then
        file=${file#"$HOME"/}
    elif [[ $file = /* ]]
    then
        debug "${file} is not in user HOME, not using."
        return 1
    fi
    printf '%s' "$file"
}

# If conky is not to be saved in new theme, pass '--tmp <filepath>'
# to store current conkys in tempfile <filepath> while making scrot.
function getConky(){
    local conkyfile conkyline saved_conkysession num_desktops CONKYCMDS CONKYTXT
    local -a idCmd
    local -A arrSTICKY
    local save=1
    if [[ $1 = '--tmp' ]]
    then
        saved_conkysession=$2 # temporary sessionfile while scrot is taken
        save=0
    else
        saved_conkysession="$CONFIGDIR/user/$CONKYSESSION"
        mkdir -p "${saved_conkysession%/*}"
    fi

    num_desktops=$(xdotool get_num_desktops)
    CONKYCMDS=''
    CONKYTXT=''

    :> "$saved_conkysession"

    pgrep -x conky -u "$USER" >/dev/null || {
        debug "No conkys are running"
        ((save)) && {
            echo '[CONKY] none' >> "$SETTINGS"
            echo -e "No conkys.\n(Any running conkys will be stopped.)\n" >> "$LISTMSG"
        }
        return 0
    }

    while read -r id;do  # get all running conky id's
        arrSTICKY["$id"]=1
    done < <(xdotool search --class conky)

    for (( d=0; d<num_desktops; d++ ));do  # get all conkys running on specific desktops
        while read -r id;do
            unset arrSTICKY["$id"] # remove from sticky list
            if [[ -n "$id" ]];then
                getIdCmd "$id" # generates array idCmd
                getCfile # extract conky config file as variable $conkyfile
                if [[ "${idCmd[*]}" == "conky" ]] || [[ "${idCmd[*]}" == "conky -q" ]];then # $conkyfile will be empty
                    conkyfile='.config/conky/conky.conf'
                    CONKYTXT="$CONKYTXT\n\tDesktop $i:  Default Conky"
                    debug "Found running default conky on Desktop $d"
                    ((save)) && debug "saving copy of default conky file"
                else
                    conkyfile=$( userFilepath "$conkyfile" ) || continue
                    CONKYTXT="$CONKYTXT\n\tDesktop $d:  ~/$conkyfile"
                    debug "Found running conky file $conkyfile on Desktop $d"
                    ((save)) && debug "Saving copy of $conkyfile"
                fi
                ((save)) && { saveFiles "$conkyfile" || {
                    echo "$0: Failed to save conky config file $conkyfile" >&2
                    return 1
                    }
                }
                # line to start on specified desktop with bl-conky-session
                conkyline="D[$d] $conkyfile"
                CONKYCMDS="${CONKYCMDS}${conkyline};" # add semicolon separator here
                echo "$conkyline" >> "$saved_conkysession"
                debug "Added '$conkyline' to saved conkysession file"
            fi
        done < <(xdotool search --desktop $((d)) --class conky)
    done

    for id in "${!arrSTICKY[@]}";do  # get commands - we don't need wmctrl for these
        if [[ -n "$id" ]];then
            getIdCmd "$id" # generates array idCmd
            getCfile # extract conky config file
            if [[ "${idCmd[*]}" == "conky" ]] || [[ "${idCmd[*]}" == "conky -q" ]];then
                conkyfile='.config/conky/conky.conf'
                CONKYTXT="$CONKYTXT\n\tDefault Conky"
                debug "Found running default conky"
                ((save)) && debug "saving copy of default conky file"
            else
                conkyfile=$( userFilepath "$conkyfile" ) || continue
                CONKYTXT="$CONKYTXT\n\t~/$conkyfile"
                debug "Found running conky file $conkyfile"
                ((save)) && debug "Saving copy of $conkyfile"
            fi
            ((save)) && { saveFiles "$conkyfile" || {
                echo "$0: Failed to save conky config file $conkyfile" >&2
                return 1
                }
            }
            conkyline="$conkyfile"
            CONKYCMDS="${CONKYCMDS}${conkyline};" # add semicolon separator here
            echo "$conkyline" >> "$saved_conkysession"
            debug "Added '$conkyline' to saved conkysession file"
        fi
    done
    ((save)) && {
        echo "[CONKY] $CONKYCMDS" >> "$SETTINGS" # semicolon-delimited list CONKYCMDS is now only a fallback in case sessionfile is missing
        echo -e "Running Conkys:\t$CONKYTXT\n" >> "$LISTMSG"
    }
    debug "\n  Saved running Conky(s)\n"
}

# If tint2 is not to be saved in new theme, pass '--tmp <filepath>'
# to store current tint2s in tempfile <filepath> while making scrot.
function getTint(){
    local tpath saved_tintsession TINTCMDS TINT2TXT
    local save=1
    if [[ $1 = '--tmp' ]]
    then
        saved_tintsession=$2 # temporary sessionfile while scrot is taken
        save=0
    else
        saved_tintsession="$CONFIGDIR/user/$TINTSESSION"
        mkdir -p "${saved_tintsession%/*}"
    fi

    TINTCMDS=""
    TINT2TXT=""

    :> "$saved_tintsession"

    pgrep -x tint2 -u "$USER" >/dev/null || {
        debug "No tint2 instances are running"
        ((save)) && {
            echo "[TINT2] none" >> "$SETTINGS"
            echo -e "No tint2.\n(Any running tint2s will be stopped.)\n" >> "$LISTMSG"
        }
        return 0
    }

    while read -r pid; do
        mapfile -d '' -t command < "/proc/${pid}/cmdline"
        [[ ${command[0]} = 'tint2' ]]  || {
            echo "$0: pgrep parsing failed: command is not 'tint2'" >&2
            continue
        }
        if (( ${#command[@]} > 1 )); then
            tpath=${command[-1]} # tint2 takes no options other than -c, which is optional
            tpath=$( userFilepath "$tpath" ) || continue # assume path is relative to $HOME
        else
            tpath='.config/tint2/tint2rc'
        fi
        [[ -f $HOME/$tpath ]] || {
            echo "$0: pgrep tint2 parsing failed: $HOME/$tpath is not a file" >&2
            continue
        }
        echo "$tpath" >> "$saved_tintsession"
        debug "Added '$tpath' to saved tintsession file"
        ((save)) || continue
        TINTCMDS="$TINTCMDS$tpath;"
        if (( ${#command[@]} == 1 ));then
            TINT2TXT="$TINT2TXT\n\tDefault Tint2"
            debug "saving copy of default tint2 config file"
        else
            TINT2TXT="$TINT2TXT\n\t~/$tpath"
            debug "saving copy of $tpath"
        fi
        saveFiles "$tpath" || {
            echo "$0: Failed to save tint2 config file $tpath" >&2
            return 1
        }
    done < <(pgrep -x 'tint2' -u "$USER")

    ((save)) && {
        echo "[TINT2] $TINTCMDS" >> "$SETTINGS" # $TINTCMDS only fallback if sessionfile is missing
        echo -e "Running Tint2s:\t$TINT2TXT\n" >> "$LISTMSG"
    }
    debug "\n  Saved running Tint2(s)\n"
}

# copy <theme> section from bl-rc.xml to obtheme.txt
function getOBtheme(){
    local obfile obtheme xpath
    obfile="$CONFIGDIR/obtheme.txt"
    [[ -r $RCFILE ]] || {
        RCFILE="$OLDRCFILE"
        debug "Getting openbox theme from $OLDRCFILE instead of $RCFILE"
    }
    [[ -r $RCFILE ]] || {
        echo "$0: Openbox config file $RCFILE not found" >&2
        return 1
    }
    xsl='<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:ob="http://openbox.org/3.4/rc">
  <xsl:output method="xml" encoding="UTF-8" omit-xml-declaration="yes" />

  <xsl:template match="/">
    <xsl:apply-templates select="/ob:openbox_config/ob:theme" />
  </xsl:template>

  <xsl:template match="*">
    <xsl:element name="{local-name()}">
      <xsl:apply-templates select="@*|node()" />
    </xsl:element>
  </xsl:template>

  <xsl:template match="@*|text()|comment()">
    <xsl:copy/>
  </xsl:template>

</xsl:stylesheet>
'
    xmlstarlet transform <(cat <<<"$xsl") "$RCFILE" > "$obfile" || return 1
    [[ -s $obfile ]] || {
        echo "$0: Failed to generate Openbox theme settings in $obfile" >&2
        return 1
    }
    # $obfile has no namespace declarations, so '_:' syntax unnecessary
    xpath='/theme/name/text()'
    obtheme=$(xmlstarlet sel --template --value-of "$xpath" "$obfile")
    [[ -n $obtheme ]] || {
        echo "$0: Failed to determine the Openbox theme name to be saved" >&2
        return 1
    }
    echo "Openbox theme:  $obtheme" >> "$LISTMSG"
    echo "[OBTHEME] $obtheme" >> "$SETTINGS"
    debug "copied Openbox theme (${obtheme}) section from $RCFILE"
}

function getGTKtheme(){
    saveFiles "$GTK2" "$GTK2MINE" "$GTK3/settings.ini" "$GTK3/gtk.css" "$GTK3x" || {
        echo "$0: Failed to save the necessary GTK config files" >&2
        return 1
    }
    getGTKname || {
        echo "$0: Failed to parse $gtk3_settings" >&2
        return 1
    }
}

function getGTKname(){ # get saved GTK3 theme name and Icon theme name
    local gtk3_settings gtktheme icontheme txt
    gtk3_settings="$CONFIGDIR/user/$GTK3/settings.ini"
    # parseKeyfile generates global associative array KEYS
    parseKeyfile "$gtk3_settings" || { yad_warning "Failed to parse $gtk3_settings."; return 1;}
    gtktheme=${KEYS[gtk-theme-name]}
    echo "[GTK] $gtktheme" >> "$SETTINGS"
    icontheme=${KEYS[gtk-icon-theme-name]}
    echo "[ICONS] $icontheme" >> "$SETTINGS"
    unset KEYS
    txt="GTK theme:  $gtktheme;  Icon Theme: $icontheme\n"
    debug "\n  Saved $txt"
    echo  "$txt" >> "$LISTMSG"
}

function getDmenu(){
    local txt
    saveFiles "$DMENU" || {
        echo "$0: Failed to save demenu config file $DMENU" >&2
        return 1
    }
    txt="dmenu config:  ~/$DMENU\n"
    debug "\n  Saved $txt"
    echo "[DMENU]" >> "$SETTINGS"
    echo "$txt" >> "$LISTMSG"
}

function getLightdm(){
    local txt
    saveFileAbs "$LDMDIR/$LDM" "$CONFIGDIR/$LDM" || {
        echo "$0: Failed to save LightDM config file $LDMDIR/$LDM to $CONFIGDIR/$LDM" >&2
        return 1
    }
    txt="Lightdm config:  $LDMDIR/$LDM\n(password will be needed to restore)\n"
    debug "\n  Saved $txt"
    echo "[LIGHTDM]" >> "$SETTINGS"
    echo "$txt" >> "$LISTMSG"
}

# passed termfile as $1 and pickterm as $2 by saveSettings()
function getTerminal(){
    local termname termfile txt
    termfile="$1"
    termname="$2"
    case "$termfile" in # dconf "directories" get prefixed with %dconf% in checkTerm()
    '%dconf%'*)
        saveDconf "${termfile#'%dconf%'}" "$termname" || {
            echo "$0: Failed to save $termname dconf config: $termfile" >&2
            return 1
        }
        txt="$termname dconf config: ${termfile#'%dconf%'}\n"
        ;;
    *)
        saveFiles "$termfile" || {
            echo "$0: Failed to save $termname configs file $termfile" >&2
            return 1
        }
        txt="$termname config:  ~/$termfile\n"
        ;;
    esac
    debug "\n  Saved $txt"
    echo "[$termname] $termfile" >> "$SETTINGS"
    echo "$txt" >> "$LISTMSG"
}

function getXconfig(){
    local txt
    saveFiles "$XFILE" || {
        echo "$0: Failed to save X configs file $XFILE" >&2
        return 1
    }
    txt="X config:  ~/$XFILE\n"
    debug "\n  Saved $txt"
    echo "[XFILE]" >> "$SETTINGS"
    echo "$txt" >> "$LISTMSG"
}

function getBashRC(){
    local txt
    saveFiles "$BASHRC" || {
        echo "$0: Failed to save bash configs file $BASHRC" >&2
        return 1
    }
    txt="Bash config:  ~/$BASHRC\n"
    debug "\n  Saved $txt"
    echo "[BASHRC]" >> "$SETTINGS"
    echo "$txt" >> "$LISTMSG"
}

function getComp(){
    local txt
    [[ -r "$HOME/$COMPFILE" ]] || COMPFILE=$OLDCOMPFILE
    saveFiles "$COMPFILE" || {
        echo "$0: Failed to save compositor configs file $COMPFILE" >&2
        return 1
    }
    txt="Compositor settings: ~/$COMPFILE\n"
    debug "\n  Saved $txt"
    echo "[COMPOSITOR] $COMPFILE" >> "$SETTINGS"
    echo "$txt" >> "$LISTMSG"
}

function getJgmenu(){
    local txt
    [[ -r $HOME/$JGMENURC ]] || {
        debug "No jgmenu config file, not saving"
        return 0
    }
    saveFiles "$JGMENURC" || {
        echo "$0: Failed to save jgmenu configs file $JGMENURC" >&2
        return 1
    }
    txt="jgmenu settings: ~/$JGMENURC\n"
    debug "\n  Saved $txt"
    echo "[JGMENU]" >> "$SETTINGS"
    echo "$txt" >> "$LISTMSG"
}

function getScrot(){
    debug "\n Preparing to take screenshot..."
    local conkyFLAG tint2FLAG currDesktop scrot mons hiddenWins
    conkyFLAG=1
    tint2FLAG=1
    grep -q "CONKY" "$SETTINGS" || {
        conkyFLAG=0    # Conkys not to be saved
        tmpConky=$(mktemp --tmpdir blob.XXXX)
        getConky --tmp "$tmpConky" # save current conky session to restore after taking scrot
        debug "Hiding Conkys - they are not to be saved to this BLOB."
        safeKill conky
    }
    grep -q "TINT2" "$SETTINGS" || {
        tint2FLAG=0    # Tint2s not to be saved
        tmpTint=$(mktemp --tmpdir blob.XXXX)
        getTint --tmp "$tmpTint" # save current tint2 session to restore after taking scrot
        debug "Hiding tint2s - they are not to be saved to this BLOB"
        safeKill tint2
    }
    currDesktop=$(xdotool get_desktop)
    debug "Current desktop is $currDesktop"
    scrot="$USRCONFIGPATH/$NEWNAME/${NEWNAME}.jpg"
    mons=$(xrandr -q | grep -c " connected")    # number of monitors

    # set mouse position, for appearance of root-menu
    local -a dim
    read -r -a dim < <(bl-xinerama-prop)
    screenW=${dim[0]}
    screenH=${dim[1]}
    if (( mons == 1 ));then # single monitor
        appX=$(( (screenW/20)*8 ))
        menuX=$(( (screenW/20)*2 ))
    else
        appX=$(( (screenW/20)*4 ))
        menuX=$(( (screenW/20)*1 ))
    fi
    appY=$(( (screenH/20)*4 ))
    menuY=$(( (screenH/20)*4 ))

    debug "minimizing open windows"
    # minimize all visible non-sticky windows on current desktop (most conkys are sticky)
    sleep 0.5 # make sure previous yad window is completely closed before listing
    hiddenWins=()
    for w in $(xdotool search --onlyvisible --desktop "$currDesktop" --name '.*')
    do
        grep -iq <<<"$(xprop WM_CLASS -id "$w")" 'conky' && continue # remove any non-sticky conkys from hide list
        hiddenWins+=("$w")
        xdotool windowminimize "$w"
    done

    # start lxappearance
    lxappearance 2>/dev/null &
    sleep 0.5
    # get lx window, make sure it loses focus, then move mouse and start root-menu
    LX=$(xdotool getwindowfocus)
    xdotool windowmove --sync "$LX" "$appX" "$appY" && sleep 0.3 && \
    xdotool mousemove --sync --window "$LX" -- -50 0 && xdotool click 1
    sleep 0.3
    xdotool mousemove --sync "$menuX" "$menuY"
    sleep 0.1
    case $OBSESSION in
    bunsenlabs)
        jgmenu_run &
        sleep 0.5
        xdotool key --delay 100 Home
        i=1
        while (( i <= KEYDOWN ));do
            xdotool key --delay 100 Down
            i=$(( i+1 ))
        done
        xdotool key --delay 50 Right
        xdotool key --delay 50 Right && sleep 0.5
        ;;
    openbox)
        xdotool key --clearmodifiers "$MENUMODIFIER"
        i=1
        while (( i <= KEYDOWN ));do
            xdotool key --delay 100 Down
            i=$(( i+1 ))
        done
        xdotool key --delay 50 Right && sleep 0.5
        ;;
    esac

    debug "Taking screenshot..."

    # take scrot
    scrot -t 9 "$scrot"    # scrot thumbnail @9% fullsize

    sleep 0.5

    debug "restoring desktop"

    # close root menu
    xdotool mousemove_relative --sync --polar 0 10 "${MOUSECMD[@]}"
    sleep 0.3
    # kill lxappearance
    pkill -P "$$" lxappearance
    sleep 0.3
    # restore hidden windows

    for w in "${hiddenWins[@]}"
    do
        xdotool windowmap --sync "$w"
        sleep 0.3
    done
    # if conkys or tint2s were killed, restore previously running session
    ((conkyFLAG)) || {
        bl-conky-session "$tmpConky"
        rm -f "$tmpConky"
        sleep 0.3
    }
    ((tint2FLAG)) || {
        bl-tint2-session "$tmpTint"
        rm -f "$tmpTint"
        sleep 0.3
    }
}

# choose terminal settings to save, based on what is x-terminal-emulator
# sets termfile and pickterm, local inside saveSettings()
function checkTerm(){
    case $( readlink /etc/alternatives/x-terminal-emulator ) in
    /usr/bin/lxterminal)
        termfile='.config/lxterminal/lxterminal.conf'
        pickterm='Lxterminal'
        ;;
    /usr/bin/terminator)
        termfile='.config/terminator/config'
        pickterm='Terminator'
        ;;
    /usr/bin/xfce4-terminal.wrapper)
        termfile='.config/xfce4/terminal/terminalrc'
        pickterm='Xfce4-terminal'
        ;;
    /usr/bin/sakura)
        termfile='.config/sakura/sakura.conf'
        pickterm='Sakura'
        ;;
    /usr/bin/gnome-terminal.wrapper)
        termfile='%dconf%/org/gnome/terminal/'
        pickterm='Gnome-terminal'
        ;;
    /usr/bin/mate-terminal.wrapper)
        termfile='%dconf%/org/mate/terminal/'
        pickterm='Mate-terminal'
        ;;
    /usr/bin/tilix.wrapper)
        termfile='%dconf%/com/gexperts/Tilix/'
        pickterm='Tilix'
        ;;
    *)
        termfile=''
        ;;
    esac
}

# NEWNAME global set by setName()
function saveSettings(){
    local configs termfile pickterm txt txt2
    configs=(
        "$PICKOB"
        "$PICKGTK"
        "$PICKBG"
        "$PICKCONKY"
        "$PICKTINT"
        "$PICKDMENU"
        "$PICKLDM"
        "$PICKX"
        "$PICKBASH"
        "$PICKCOMP"
        "$PICKJGMENU"
    )
    checkTerm # sets termfile and pickterm
    # add terminal to array if one with a config file is in use
    if  [[ -n $termfile ]];then
        configs+=("$pickterm")
    fi
    for item in "${configs[@]}";do # now saving all configs
        case "$item" in
            "$PICKOB"   )   getOBtheme
                            ;;
            "$PICKGTK"  )   getGTKtheme
                            ;;
            "$PICKBG"   )   getBg
                            ;;
            "$PICKCONKY")   getConky
                            ;;
            "$PICKTINT" )   getTint
                            ;;
            "$PICKDMENU")   getDmenu
                            ;;
            "$PICKLDM"  )   getLightdm
                            ;;
            "$PICKX"    )   getXconfig
                            ;;
            "$PICKBASH" )   getBashRC
                            ;;
            "$PICKCOMP" )   getComp
                            ;;
            "$PICKJGMENU")  getJgmenu
                            ;;
            "$pickterm" )   getTerminal "$termfile" "$pickterm"
                            ;;
            *           )   echo "$0:  Unknown config value in saveSettings function" >&2
                            exit 1
                            ;;
        esac
    done
    txt="<big><b><u>Theming Configurations to be saved:</u></b></big>\n\n"
    txt2=$(cat "$LISTMSG")
    yad_prompt "$txt$txt2"
    ret=$?
    if (( ret == 1 ));then
        cleanup all
        return 1
    else
        debug "Current configs saved as \"$NEWNAME\""
        echo "$NEWNAME" > "$CURSESSFILE"     # replace entry in saved config flag file
    fi
}

###################### end save functions ##############################

###################### restore functions ###############################

# pass icon theme name as $1
function checkICONS(){ # check if icon theme is still present
#    local ICOTXT="Icon theme <b>$1</b> not found\n\n  The default icon theme will be used..."
    debug "Checking for icon theme $1"
    for i in "${iconPaths[@]}";do # iconPaths defined at top
        if [[ -d "$i/$1" ]];then
            debug "\n  Found $1 icon theme"
            return 0
        fi
    done
    local pkg="${icon_pkgs[$1]}"
    if [[ -n "${pkg}" ]] && hash bl-install >/dev/null
    then
        debug "\n  Icon theme  $1  was not found\n  Offering to install $pkg..."
        local INSTICOTXT="Needed icon theme <b>$1</b> not found\n Would you like to install the package <b>${pkg}</b> which contains that theme?"
        if yad_question "$INSTICOTXT"
        then
            local retfile retval
            retfile="$( mktemp )"
            bl-install -f "$retfile" "$pkg"
            # sleep 0.3 # allow time for bl-install to write to $retfile (now done in bl-install)
            retval="$(<"$retfile")"
            rm "$retfile"
            if [[ "$retval" = 0 ]]
            then
                return 0
            else
                yad_warning "Package install failed."
            fi
        fi
    fi
    debug "\n  Icon theme  $1  was not found"
#        yad_warning "$ICOTXT"
    return 1
}

# pass GTK theme name as $1
function checkGTK(){    # check if gtk theme is still present
    local INSTGTKTXT="Needed GTK theme <b>$1</b> not found\n Would you like to install the package <b>${pkg}</b> which contains that theme?"
    local NOGTKTXT="GTK theme <b>$1</b> not found\n\n  Continue with the current GTK theme, or exit?"
    debug "Checking for GTK theme $1"
    for i in "${gtkPaths[@]}";do # gtkPaths defined at top
        if [[ -d "$i/$1" ]];then
            debug "\n  Found $1 GTK theme"
            return 0
        fi
    done
    local pkg="${theme_pkgs[$1]}"
    if [[ -n "${pkg}" ]] && hash bl-install >/dev/null
    then
        debug "\n  GTK theme  $1  was not found\n  Offering to install $pkg..."
        if yad_question "$INSTGTKTXT"
        then
            local retfile retval
            retfile="$( mktemp )"
            bl-install -f "$retfile" "$pkg"
            # sleep 0.3 # allow time for bl-install to write to $retfile (now done in bl-install)
            retval="$(<"$retfile")"
            rm "$retfile"
            if [[ "$retval" = 0 ]]
            then
                return 0
            else
                yad_warning "Package install failed."
            fi
        fi
    fi
    debug "\n  GTK theme  $1  was not found"
#    yad_warning_option "$NOGTKTXT"
    return 1
}

# restoreIcons <icontheme>
# $1 is $VAL from restoreSettings()
# This function is used only when not restoring GTK settings, icon theme is included there.
function restoreIcons(){
    local new_icon_theme new_gtk3_settings new_icon_theme
#    new_icon_theme=$1
    new_gtk3_settings="$THEMEPATH/user/$GTK3/settings.ini"
    parseKeyfile "$new_gtk3_settings" # GTK settings will not be restored, reading icon theme only
    new_icon_theme=${KEYS[gtk-icon-theme-name]}
    debug "Setting icon theme $new_icon_theme found in $new_gtk3_settings"
    checkICONS "$new_icon_theme" || {
        local NOICOTXT="Icon theme <b>$new_icon_theme</b> not found\n\n  The current icon theme will be used."
        yad_warning "$NOICOTXT"
        debug "Icon theme $new_icon_theme was not found, continuing to use the current icon theme."
        return 0
    }
    debug "\nSetting icon theme to $new_icon_theme, GTK theme is unchanged."
    editKeyfile "$current_gtk3_settings" "gtk-icon-theme-name=$new_icon_theme"
    unset KEYS
    reloadGTK
}


# THEMEPATH is global set by displayBlobs()
# restoreGTK [--noicons] <gtktheme> <icontheme>
# gtk/icon themes to be restored are $VAL from restoreSettings()
#  (these could be parsed from "$THEMEPATH/user/$GTK3/settings.ini" instead)
# option --noicons causes icon theme to be reset to current setting
function restoreGTK(){
    local restore_icons current_gtk3_settings new_gtk3_settings current_gtk_theme new_gtk_theme current_icon_theme new_icon_theme
    restore_icons=true
    [[ $1 = '--noicons' ]] && { restore_icons=false; debug "Not setting a new icon theme."; shift; }
#    new_gtk_theme=$1
#    [[ -n $2 ]] && new_icon_theme=$2
    current_gtk3_settings="$HOME/$GTK3/settings.ini"
    new_gtk3_settings="$THEMEPATH/user/$GTK3/settings.ini"
    parseKeyfile "$current_gtk3_settings" # settings before restoring files with new theme
    current_gtk_theme=${KEYS[gtk-theme-name]}
    current_icon_theme=${KEYS[gtk-icon-theme-name]}
    debug "current gtk theme is ${current_gtk_theme}, icon theme is $current_icon_theme"
    parseKeyfile "$new_gtk3_settings" # settings before restoring files with new theme
    new_gtk_theme=${KEYS[gtk-theme-name]}
    new_icon_theme=${KEYS[gtk-icon-theme-name]}

    debug "Setting GTK theme $new_gtk_theme found in $new_gtk3_settings"
    checkGTK "$new_gtk_theme" || {
        local NOGTKTXT="GTK theme <b>$new_gtk_theme</b> not found\n\n  Continue with the current GTK theme, or exit?"
        if yad_warning_option "$NOGTKTXT"; then
            debug "$new_gtk_theme not found, continuing with current GTK theme $current_gtk_theme"
            if [[ $restore_icons = 'true' ]]; then
                debug "icon theme will be restored"
                restoreIcons "$new_icon_theme" || return 1
            fi
            return 0
        else
            exit 1
        fi
    }

    [[ $restore_icons = 'true' ]] && {
        debug "Setting icon theme $new_icon_theme found in $new_gtk3_settings"
        checkICONS "$new_icon_theme" || {
            local NOICOTXT="Icon theme <b>$new_icon_theme</b> not found\n\n  The current icon theme will be used."
            yad_warning "$NOICOTXT"
            restore_icons=false
        }
    }

    safeKill jgmenu # If jgmenu is not running, GTK3 file edit will not trigger hook.
    restoreFiles "$GTK2" "$GTK2MINE" "$GTK3" "$GTK3x"
    # $HOME/$GTK3/settings.ini has now been updated, need to parse again
    [[ $restore_icons = 'false' ]] && {
        debug "Setting icon theme back to current $current_icon_theme"
        editKeyfile "$current_gtk3_settings" "gtk-icon-theme-name=$current_icon_theme"
    }
    unset KEYS # global KEYS is set by parseKeyfile in editKeyfile
    # If jgmenu cache is set, restart will not trigger GTK sync.
    # This means GTK sync will have to be done in this script, if wanted.
    # Currently done in restoreSettings().
    jgmenu_write_gtkcache "$current_gtk3_settings"
    reloadGTK
    reloadXfceNotifyd
    # restartThunar # not needed now that bl-reload-gtk23 updates xsettings
}

function reloadGTK(){ # reload gtk theme after restoring saved config
    debug "\nReloading GTK theme..."
    if ((DEBUG_FLAG)); then
        bl-reload-gtk23 --force && debug "\nbl-reload-gtk23: done\n" || echo "bl-reload-gtk23 failed" >&2
    else
        bl-reload-gtk23 --force >/dev/null 2>&1 || echo "bl-reload-gtk23 failed" >&2
    fi
}

# pass gtk keyfile as $1, parse GTK theme from there instead of accepting name in settings.cfg
function jgmenu_write_gtkcache(){
    local gtktheme jgmenu_cachedir
    jgmenu_cachedir="$HOME/.cache/jgmenu"
    mkdir -p "$jgmenu_cachedir"
    parseKeyfile "$1" || { yad_warning "Failed to parse $1."; return 1;}
    gtktheme=${KEYS[gtk-theme-name]}
    debug "Setting $gtktheme as GTK theme in jgmenu cache."
    printf '%s' "$gtktheme" > "$jgmenu_cachedir/.last-gtktheme"
    unset KEYS
}

# next time xfce4-notifyd is called it will restart the two daemons, with latest config
function reloadXfceNotifyd(){
    debug "Stopping xfconf and xfce4-notify daemons."
    safeKill xfconfd
    safeKill xfce4-notifyd
}

function checkOBTHEME(){
    local FOUNDOB=0
    local OBTXT="Openbox theme <b>$1</b> not found\n\n  The default Openbox theme will be used..."
    for i in "${gtkPaths[@]}";do # gtkPaths defined at top
        if [[ -d "$i/$1/openbox-3" ]];then
            debug "\n  Found $1 Openbox theme"
            FOUNDOB=1
            break
        fi
    done
    if (( FOUNDOB == 0 ));then
        debug "\n  OB theme  $1  was not found\n  The default Openbox theme will be used..."
        yad_warning "$OBTXT"
    fi
}

# escape filepaths for xmlstarlet
urlencode() {
    local LC_ALL=C c i e=''
    for (( i = 0; i < ${#1}; i++ )); do
        c=${1:i:1}
        case $c in
            [[:alnum:].~_-]) ;;
            *) printf -v c '%%%02X' "'$c" ;;
        esac
        e+=$c
    done
    printf '%s' "$e"
}

# RCFILE and OLDRCFILE set in USER CONFIG VARIABLES at top.
# THEMEPATH and BKP_SFX are globals,
# set by displayBlobs() and restoreSettings() respectively.
function restoreOBrc(){
    local themefile rcbkp xsl
    themefile="$THEMEPATH/obtheme.txt"
    [[ -r $RCFILE ]] || {
        RCFILE="$OLDRCFILE"
        debug "Restoring theme from $themefile to $OLDRCFILE instead of $RCFILE"
    }
    # backup bl-rc.xml first
    rcbkp="${RCFILE}${BKP_SFX}"
    cp "$RCFILE" "$rcbkp"
    # remove older backups
    for f in "$OBPATH"/*.blob~ ;do
        if [[ $f -ot $rcbkp ]];then
            rm "$f"
        fi
    done
    debug "\n  $RCFILE backed up as $rcbkp"
    # Replace <theme> element in $RCFILE from $themefile:
    xsl='<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:ob="http://openbox.org/3.4/rc" >
  <xsl:output method="xml" encoding="UTF-8" />
  <xsl:param name="themefile" /> <!-- must url encode this file path -->

  <xsl:template match="@*|node()">
    <xsl:copy>
      <xsl:apply-templates select="@*|node()" />
    </xsl:copy>
  </xsl:template>

  <xsl:template match="ob:theme">
    <xsl:apply-templates  select="document($themefile)" />
  </xsl:template>
  <!-- create elements with default namespace -->
  <xsl:template match="*" >
    <xsl:element name="{local-name()}" namespace="http://openbox.org/3.4/rc">
      <xsl:apply-templates select="@*|node()" />
    </xsl:element>
  </xsl:template>

  <xsl:template match="@*|text()|comment()">
    <xsl:copy/>
  </xsl:template>

</xsl:stylesheet>
'
    themefile="file://$(urlencode "$themefile")"
    xmlstarlet transform <(cat <<<"$xsl") -p themefile="'$themefile'"  "$RCFILE" > "${RCFILE}_tmp" || return 1
    cat "${RCFILE}_tmp" > "$RCFILE" || return 1
    rm "${RCFILE}_tmp"
    debug "\n  $RCFILE edited for OB theme"
    openbox --reconfigure || return 1
    debug "\n Openbox reconfigured"
}

function restoreConky(){    # $1 = $VAL from restoreSettings()
    local conkycmds currDesktop user_conkysession saved_conkysession
    conkycmds="${1//;/$'\n'}" # only used as fallback if there is no sessionfile
    user_conkysession="$HOME/$CONKYSESSION"
    saved_conkysession="$THEMEPATH/user/$CONKYSESSION"
    # cd only applies during subshell
    (
        cd "$THEMEPATH/user" && {
            shopt -s globstar dotglob nullglob
            for i in **/*conky*.conf **/*conkyrc **/*conky
            do
                [[ -f "$i" ]] || continue
                debug "restoring conky file $i"
                restoreFiles "$i" || echo "$0: failed to restore conky file $i" >&2
            done
            shopt -u globstar dotglob nullglob
        }
    )
    if [[ -f $saved_conkysession ]]
    then
        debug "Restoring conky sessionfile."
    elif [[ -n $conkycmds ]]
    then
        debug "No saved conkysession file found, using commands in settings.cfg"
        if [[ $conkycmds = 'none' ]]
        then
            debug "No saved conkys - removing content of conky sessionfile."
            :> "$saved_conkysession"
        else
            echo "$conkycmds" > "$saved_conkysession"
        fi
    else
        echo "$0: cannot restore conky, there is no session information." >&2
        return 1
    fi
    restoreFiles "$CONKYSESSION" || {
        echo "$0: failed to restore conky session $saved_conkysession" >&2
        return 1
    }
    hash bl-conky-session || return 1 # bl-conky-session should be available - it comes with bl-obthemes in bunsen-utilities
    bl-conky-session --kill-running "$user_conkysession" || { # bl-conky-session can handle old-style sessionfiles, desktops too
        "$0: failed to start conky session $user_conkysession with bl-conky-session" >&2
        return 1
    }
    debug "\n  Restored Conky\n"
}

function restoreTint2(){    # $1 = $VAL from restoreSettings()
    local tintcmds user_tintsession saved_tintsession
    tintcmds="${1//;/$'\n'}"
    user_tintsession="$HOME/$TINTSESSION"
    saved_tintsession="$THEMEPATH/user/$TINTSESSION"
    # restore any tint2 configs that have been saved
    # assume they are all in the tint2 directory
    [[ -d "$THEMEPATH/user/.config/tint2" ]] || {
        echo "$0: cannot restore tint2, directory $THEMEPATH/user/.config/tint2 does not exist" >&2
        return 1
    }
    if [[ -f "$saved_tintsession" ]]
    then
        debug "Restoring tint2 sessionfile."
    elif [[ -n $tintcmds ]]
    then
        debug "No saved tintsession file found, using filepaths in settings.cfg"
        if [[ $tintcmds = 'none' ]]
        then
            debug "No saved tint2s - generating empty tint2 sessionfile."
            :> "$saved_tintsession"
        else
            echo "$tintcmds" > "$saved_tintsession"
        fi
    else
        echo "$0: cannot restore tint2, there is no session information." >&2
        return 1
    fi
    restoreFiles  '.config/tint2' || { # restoreFiles will restore whole directory with contents
        echo "$0: failed to restore user/.config/tint2 directory in $THEMEPATH" >&2
        return 1
    }
    if hash bl-tint2-session # bl-tint2-session should be present, it comes in bunsen-utilities, with bl-obthemes
    then
        bl-tint2-session "$user_tintsession" || {
            echo "$0: failed to start tint2 session $user_tintsession with bl-tint2-session" >&2
            return 1
        }
    fi
    debug "\n Restored Tint2\n"
}

# THEMEPATH and BKP_SFX are globals,
# set by displayBlobs() and restoreSettings() respectively.
function restoreLightdm(){   # need sudo to restore lightdm-gtk-greeter.conf
    local msg ret
    [[ -r "$THEMEPATH/$LDM" ]] || {
        echo "$0: Cannot read file $THEMEPATH/$LDM" >&2
        return 1
    }
    diff -qBEbZ "$THEMEPATH/$LDM" "$LDMDIR/$LDM" >/dev/null && {
        debug "\n $THEMEPATH/$LDM and $LDMDIR/$LDM are identical, no need to restore."
        return 0
    }
    while true;do
        msg="Please enter your password to edit the system file lightdm-gtk-greeter.conf"
        yad_prompt "$msg" --entry --hide-text | sudo -S cp --backup --suffix="$BKP_SFX" "$THEMEPATH/$LDM" "$LDMDIR/$LDM" 2>/dev/null
        ret=( "${PIPESTATUS[@]}" )
        if [[ ${ret[1]} = 0 ]]
        then
            msg="Restored: lightdm-gtk-greeter.conf"
            debug "\n  $msg"
            return 0
        elif [[ ${ret[0]} = 1 ]]
        then
            msg="Authentication cancelled\n\nlightdm-gtk-greeter.conf was not restored"
            echo "$0: $msg" >&2
            return 1
        else
            msg="Password input failed\n\nlightdm-gtk-greeter.conf was not restored"
            echo "$0: $msg" >&2
            yad_warning "$msg"
        fi
    done
}

# $1 [$2...] are relative paths passed from displayBlobs()
# THEMEPATH is global set by displayBlobs()
# If source is directory, its contents will be copied to the equivalent user directory.
function restoreFiles(){
    local src_file target_file i
    for i in "$@"
    do
        debug "\nRestoring ${i}..."
        src_file="$THEMEPATH/user/$i"
        target_file="$HOME/$i"
        if [[ -d $src_file ]]; then
            copyDir "$src_file" "$target_file" || return 1
        elif [[ -f $src_file ]]; then
            restoreFileAbs "$src_file" "$target_file" || return 1
        else
            echo "$0: File to restore, $src_file does not exist." >&2
            return 1
        fi
    done
}

# Copy all the contents of a directory, recursively.
# $1 and $2 are absolute paths of source and target directories.
function copyDir(){
    local src_dir target_dir i
    src_dir="$1"
    target_dir="$2"
    if [[ -f $target_dir ]]
    then
        echo "$0: target directory $target_dir is an ordinary file" >&2
        return 1
    fi
    debug "\n  making directory $target_dir"
    mkdir -p "$target_dir" || return 1
    for i in "$src_dir"/*
    do
        [[ -e "$i" ]] || continue
        if [[ -d "$i" ]]
        then
            copyDir "$i" "$target_dir/${i##*/}" || return 1
        else
            restoreFileAbs "$i" "$target_dir/${i##*/}" || return 1
        fi
    done
}

# $1 and $2 are absolute source and target filepaths
# BKP_SFX is global set by restoreSettings()()
function restoreFileAbs(){
    local src_file src_content tmpsrc target_file target_dir bkp_file extra_txt
    src_file="$1"
    target_file="$2"
    target_dir="${target_file%/*}"
    mkdir -p "$target_dir" || return 1
    extra_txt=''
    grep -qF "$HOME_MARKER" "$src_file" && {
        src_content=$(< "$src_file" )
        tmpsrc="$(mktemp)" || return 1
        echo "${src_content//$HOME_MARKER/$HOME}" > "$tmpsrc"
        src_file=$tmpsrc
        extra_txt=' (home path adjusted)'
    }
    if [[ -e $target_file ]];then        # backup config first
        diff -qBEbZ "$src_file" "$target_file" >/dev/null && {
            debug "\n  $target_file and ${1}${extra_txt} are identical, no need to restore."
            return 0
        }
        needBackup "${target_file}" && {
            bkp_file="${target_file}${BKP_SFX}"
            mv "$target_file" "$bkp_file" || return 1
            debug "\n  $target_file backed up"
        }
        cp "$src_file" "$target_file" || return 1
        debug "\n  $target_file restored"
    else
        cp "$src_file" "$target_file" || return 1
        debug "\n  $target_file did not exist, now added"
    fi
    rm -f "$tmpsrc"
}

# Take absolute filepath (in $HOME) as $1, from restoreFileAbs().
# Check if an identical backed-up file already exists, and if not,
# search for identical file in existing saved BLOBs.
# Return 1 if found (no backup needed before overwrite),
# otherwise return 0 (do backup).
needBackup(){
    local file bkp_file path dir blobfile homefile_content blobfile_content
    file=$1
    for bkp_file in "${file}"*~
    do
        [[ -f $bkp_file ]] || continue
        diff -qBEbZ "$file" "$bkp_file" >/dev/null && {
            debug "$file already has identical backup ${bkp_file}, no need to backup again"
            return 1
        }
    done
    path="${file#$HOME/}"
    for dir in "$USRCONFIGPATH"/*/user "$SYSCONFIGPATH"/*/user
    do
        [[ -f $dir/$path ]] || continue
        blobfile=$dir/$path
        if grep -qF "$HOME_MARKER" "$blobfile"; then
            homefile_content=$(< "$file" )
            blobfile_content=$(< "$blobfile" )
            [[ "$homefile_content" = "${blobfile_content//$HOME_MARKER/$HOME}" ]]  && {
                debug "$file has identical copy $blobfile, no need to backup"
                return 1
            }
        else
            diff -BEbZ "$file" "$blobfile" >/dev/null && {
                debug "$file has identical copy ${blobfile}, no need to backup"
                return 1
            }
        fi
    done
    return 0
}

# THEMEPATH and BKP_SFX are globals set by displayBlobs() and restoreSettings() respectively.
# dconfdir and appname passed as $1 and $2 from restoreSettings()
# dconfdir is a dconf path, not a file path.
function restoreDconf(){
    local dconfdir appname src_file bkpdir bkp_file current_state blob_state
    dconfdir=$1
    appname=$2
    src_file="$THEMEPATH/dconf/${appname// /_}"
    [[ -f $src_file ]] || {
        echo "$0: cannot find dconf config $src_file for ${appname}" >&2
        return 1
    }
    bkpdir="$HOME/.config/dconf-backups"
    bkp_file="$bkpdir/${appname// /_}${BKP_SFX}"
    current_state=$( dconf dump "$dconfdir" ) || return 1
    blob_state=$(< "$src_file" )
    [[ $current_state = "$blob_state" ]] && { # including when both are empty, ie default state
        debug "${appname}: no need to restore dconf, settings are the same."
        return 0
    }
    [[ -n $current_state ]] && {
        mkdir -p "$bkpdir" || return 1
        debug "${appname}: backing up dconf settings to $bkp_file"
        printf '%s\n' "$current_state" > "$bkp_file" || return 1
        dconf reset -f "$dconfdir" || return 1
    }
    [[ -n $blob_state ]] && {
        debug "${appname}: restoring dconf settings from $src_file"
        dconf load "$dconfdir" < "$src_file" || return 1
    }
}

# This function is run in displayBlobs() below
# CURRENTSESSION and NUMDIRS from getCurrent()
# DLGARR and CURRENTSESSDIR are local to displayBlobs()
function UpdateDisplayDialog(){   # list saved theme collections for yad as DLGARR
    getCurrent                    # get name of latest set BLOB config
    if (( NUMDIRS == 0 ));then  # no saved configs; go back to Intro dialog
        Intro
    fi
    local seticon themename thumbnail
    declare -A uniqnames # hide duplicate directories
    DLGARR=()
    for dir in "$USRCONFIGPATH"/* "$SYSCONFIGPATH"/* ;do
        [[ -d $dir && -e $dir/settings.cfg ]] || continue
        themename="${dir##*/}" # strip path
        themename=${themename// /_}   # replace any spaces in dir name
        [[ "${uniqnames[$themename]}" = 'found' ]] && continue
        uniqnames["$themename"]='found'
        # get name of current session, set icon for TRUE/FALSE
        if [[ $CURRENTSESSION = "$themename" ]];then
            seticon="gtk-yes"
            CURRENTSESSDIR="$dir"
        elif [[ "$dir" = "$SYSCONFIGPATH"/* ]]; then
            seticon="system"
        else
            seticon="gtk-home"
        fi
        thumbnail="$dir/$themename-thumb.jpg"
        [[ -r $thumbnail ]] || thumbnail='None'     # placeholder if no thumbnail found
        DLGARR+=( "$seticon" "<big>$themename</big>" "$thumbnail" )
    done
}

# This function is run in displayBlobs() below to set width and height for View dialog.
# generates DLGWIDTH and DLGHEIGHT, local to displayBlobs()
function getActiveMonitorDimensions(){   #
    local -a dim
    read -r -a dim < <(bl-xinerama-prop)
    DLGWIDTH=$(( dim[0] / 3 ))
    DLGHEIGHT=$(( dim[1] * 2 / 3 ))
    [[ $DLGWIDTH =~ ^[0-9]+$ ]] && [[ $DLGHEIGHT =~ ^[0-9]+$ ]] || {
        print 'Error in getActiveMonitorDimensions'
        exit 1
    }
}

# This function is run in displayBlobs() below
# global THEMEPATH is set there
# themename is local to displayBlobs()
restoreSettings() {
    # get chosen saved configs and restore them
    # Conky and Tint2 will be killed by their restore functions, if called.
    BKP_SFX=".$(date +"%Y%m%d-%H%M%S").blob~" # global: unified backup suffix that restore functions will use
    local TAG VAL labels label columns select ret CHOICE jgmenu_sync jgmenu_sync_ob jgmenu_sync_gtk
    daemon_bgsetters=(xfdesktop) # If any of these are running, cannot use nitrogen or feh.
    labels=()
    declare -A values
    while read -r TAG VAL; do
        case "$TAG" in
            "[OBTHEME]"     )   labels+=("$PICKOB")       # Order of associative array values is not defined,
                                values["$PICKOB"]="$VAL"  # but indexed array "labels" preserves order of settings.cfg.
                                ;;
            "[GTK]"         )   labels+=("$PICKGTK")
                                values["$PICKGTK"]="$VAL"
                                ;;
            "[ICONS]"       )   labels+=("$PICKICONS")
                                values["$PICKICONS"]="$VAL"
                                ;;
            "[BACKGROUND]"  )   for i in "${daemon_bgsetters[@]}"
                                do
                                    pgrep -x "$i" -u "$USER" && {
                                        debug "$0: unsupported background setter $i is running"
                                        VAL="None"
                                    }
                                done
                                [[ $VAL = None ]] || {
                                    labels+=("$PICKBG")
                                    values["$PICKBG"]="$VAL"
                                }
                                ;;
            "[CONKY]"       )   labels+=("$PICKCONKY")
                                values["$PICKCONKY"]="$VAL"
                                ;;
            "[TINT2]"       )   labels+=("$PICKTINT")
                                values["$PICKTINT"]="$VAL"
                                ;;
            "[DMENU]"       )   labels+=("$PICKDMENU")
                                values["$PICKDMENU"]="$VAL"
                                ;;
            "[LIGHTDM]"     )   labels+=("$PICKLDM")
                                values["$PICKLDM"]="$VAL"
                                ;;
            "[EXITRC]"      )   : # do nothing
                                ;;
            "[XFILE]"       )   labels+=("$PICKX")
                                values["$PICKX"]="$VAL"
                                ;;
            "[BASHRC]"      )   labels+=("$PICKBASH")
                                values["$PICKBASH"]="$VAL"
                                ;;
            "[COMPOSITOR]"  )   labels+=("$PICKCOMP")
                                values["$PICKCOMP"]="$VAL"
                                ;;
            "[JGMENU]"      )   labels+=("$PICKJGMENU")
                                values["$PICKJGMENU"]="$VAL"
                                ;;
            '['*']'         )   TAG="${TAG#[}" # strip outside brackets
                                TAG="${TAG%]}"
                                labels+=("$TAG")
                                values["$TAG"]="$VAL"
                                ;;
            *               )   echo "$0: Ignoring unknown value: ${TAG} in $THEMEPATH/settings.cfg" >&2
                                ;;
        esac
    done < "$THEMEPATH/settings.cfg"

    select='TRUE'
    while true
    do
        columns=()
        for i in "${labels[@]}"
        do
            columns+=("$select" "$i")
        done
        CHOICE=$(yad "${yad_args[@]}" --list --checklist \
            --title="Choose the configs to restore..." \
            --button="Unselect All:2" $CANCEL $OK \
            --height=400 --width=400 \
            --print-column=2 --separator='' \
            --column="Select" --column="Config" "${columns[@]}" )
        ret=$?
        if (( ret == 1 )); then # cancel button pressed
            debug " Cancelled restore of $themename"
            return
        elif (( ret == 2 ));then
            select="FALSE"
            continue
        fi
        if [[ -z $CHOICE ]] ; then # entry field is empty, so try again
            yad_question "\n  Make a selection...." $EXIT $OK
            if (( $? == 1 ));then
                exit 0
            else
                select='FALSE'
                continue
            fi
        fi
        break
    done

    # Offer to exit if any restore function fails.
    # TODO: add 'return 1' to functions as needed
    trap 'trap_error $LINENO "$FUNCNAME" "$BASH_COMMAND"' ERR

    jgmenu_sync=true
    jgmenu_sync_ob=false
    jgmenu_sync_gtk=false
    restore_gtk=false
    restore_icons=false
    # Go through user's selected choices.
    while read -r label
    do
        VAL="${values[$label]}"
        VAL="${VAL//$HOME_MARKER/$HOME}" # HOME_MARKER is global
        debug "\n Restoring $label${VAL:+ with $VAL}"
        case "$label" in
            "$PICKOB"       )   [[ -n $VAL ]] && checkOBTHEME "$VAL"
                                restoreOBrc
                                jgmenu_sync_ob=true
                                ;;
#            "$PICKGTK"      )   [[ -n $VAL ]] && checkGTK "$VAL"
#                                [[ -n ${values[$PICKICONS]} ]] && {
#                                    debug "\n Restoring $PICKICONS with ${values[$PICKICONS]}"
#                                    checkICONS "${values[$PICKICONS]}"
#                                }
#                                restoreGTK
#                                jgmenu_sync_gtk=true
#                                # reloadGTK now called in restoreGTK
#                                # jgmenu GTK syncing will be inhibited unless OB is not restored
#                                ;;
#            "$PICKICONS"    )   [[ -n $VAL ]] && checkICONS "$VAL"
#                                ;;
            "$PICKGTK"      )   restore_gtk="${VAL:-true}"
                                ;;
            "$PICKICONS"    )   restore_icons="${VAL:-true}"
                                ;;
            "$PICKBG"       )   if [[ $VAL = FEH ]];then
                                    restoreFiles "$FEHFILE"
                                    source "$HOME/$FEHFILE"
                                else
                                    restoreFiles "$NITROFILE"
                                    nitrogen --restore
                                fi
                                ;;
            "$PICKCONKY"    )   restoreConky "$VAL"
                                ;;
            "$PICKTINT"     )   restoreTint2 "$VAL"
                                ;;
            "$PICKDMENU"    )   restoreFiles "$DMENU"
                                ;;
            "$PICKLDM"      )   restoreLightdm
                                ;;
            "$PICKX"        )   restoreFiles "$XFILE"
                                xrdb ~/.Xresources
                                ;;
            "$PICKBASH"     )   restoreFiles "$BASHRC"
                                ;;
            "$PICKJGMENU"   )   restoreFiles "$JGMENURC"
                                jgmenu_sync=false # no need for openbox or gtk theme syncing, theme is provided in $JGMENURC
                                ;;
            *               )   if [[ $VAL = '%dconf%'* ]] # dconf directories come prefixed with %dconf% in checkTerm (and others in future?)
                                then
                                    restoreDconf "${VAL#'%dconf%'}" "$label"
                                else
                                    restoreFiles "$VAL"
                                fi
                                ;;
        esac
    done <<< "$CHOICE"
    
    if [[ $restore_gtk != 'false' ]]; then
        if [[ $restore_icons != 'false' ]]; then
            restoreGTK "$restore_gtk" "$restore_icons" # restoreGTK will restore GTK settings including icons
            jgmenu_sync_gtk=true
        else
            restoreGTK --noicons "$restore_gtk" # icon theme will be reset to current theme
            jgmenu_sync_gtk=true
        fi
    else
        if [[ $restore_icons != 'false' ]]; then
            restoreIcons "$restore_icons" # only icon theme will be set
        fi
    fi
    
    hash jgmenu_run 2>/dev/null && [[ $jgmenu_sync = 'true' ]] && {
        if [[ $jgmenu_sync_ob = 'true' ]]
        then
            jgmenu_run init --apply-obtheme && debug "\n jgmenu synced with openbox theme"
        elif [[ $jgmenu_sync_gtk = 'true' ]]
        then
            jgmenu_run init --apply-gtktheme && debug "\n jgmenu synced with gtk theme"
        else
            debug "\n jgmenu theme not changed"
        fi
    }
    trap - ERR # remove trap for normal error handling
    echo "$themename" > "$CURSESSFILE"
}

# used in displayBlobs() below and intro()
# NEWNAME CONFIGDIR and CONFIGDIR_BKP are globals set by setName()
function saveNewBlob() {
    setName || return 1
    debug "\n  Saving settings as $NEWNAME"
    saveSettings || return 1
    getScrot
    yad_prompt "Settings were saved as <b>$NEWNAME</b>" --image="gtk-save" "$OK"
    if [[ -d $CONFIGDIR_BKP ]];then
        rm -rf "$CONFIGDIR_BKP"
        debug "\n  Temporary backup of $CONFIGDIR deleted\n"
    fi
}

# used in displayBlobs() below
# tests if every file in $1 is identical with its equivalent in $2
# (files not present in both directories are ignored)
# $1 is usually the blob theme directory and $2 is usually $HOME
# difflist is local inside displayBlobs()
function sameFiles() {
    local smalldir bigdir dir file bigdirfile file_content bigdirfile_content
    smalldir=$1
    bigdir=$2
    difflist=()
    debug "Comparing $smalldir and $bigdir"
    for dir in "$smalldir" "$bigdir"
    do
        [[ -d $dir ]] || {
            echo "$0: ${dir} is not a directory." >&2
            return 1
        }
    done
    shopt -s globstar dotglob
    for file in "$smalldir"/**
    do
        [[ -f $file ]] || continue
        bigdirfile=${file/#$smalldir/$bigdir}
        [[ -f $bigdirfile ]] || continue
        extra_txt=''
        if grep -qF "$HOME_MARKER" "$file"; then
            file_content=$(< "$file" )
            bigdirfile_content=$(< "$bigdirfile" )
            extra_txt=' (home path adjusted)'
            [[ "${file_content//$HOME_MARKER/$HOME}" = "$bigdirfile_content" ]] || {
                debug "${file}${extra_txt} is different from $bigdirfile"
                difflist+=("$bigdirfile")
            }
        else
            diff -BEbZ "$file" "$bigdirfile" >/dev/null || {
                debug "${file} is different from $bigdirfile"
                difflist+=("$bigdirfile")
            }
        fi
    done
    shopt -u globstar dotglob
    [[ ${#difflist[@]} -eq 0 ]] && {
        debug "All files in $smalldir are identical with those in $bigdir"
        return 0
    }
    return 1
}

# compare 2 files, opening new terminal window if needed
# If --title is passed it will be used as title of a new terminal (if opened).
# Usage: differ [--title] firstfile secondfile
differ () {
    local title firstfile secondfile diffcmd
    if [[ $1 = '--title' ]]
    then
        title=$2
        shift 2
    fi
    firstfile=$1
    secondfile=$2
    # if a GUI diff is available, use that instead
    for gui in meld kompare diffuse
    do
        hash "$gui" 2>/dev/null && {
            "$gui" "$firstfile" "$secondfile"
            return
        }
    done
    diffcmd=(colordiff -s -u)
    type colordiff >/dev/null 2>&1 || diffcmd=(diff -s -u)
    diffcmd+=("$firstfile" "$secondfile")
    if [[ -t 0 && -t 1 ]] # on terminal
    then
        "${diffcmd[@]}"
    else
        local termname termcmd
        [[ -n $title ]] || title="Diff of $firstfile and $secondfile"
        termname=$( readlink -f "$( which x-terminal-emulator )" )
        termname=${termname##*/}
        badterm_msg="$0: cannot display file diff with new window ${termname}."
        case $termname # cope with terminal inconsistencies
        in
            lxterminal)
                termcmd=(lxterminal --no-remote -T "$title" -e) # otherwise lxterminal does not start a new process
                ;;
            mate-terminal.wrapper)
                termcmd=(mate-terminal --disable-factory -t "$title" -x) # mate-terminal.wrapper does not support --disable-factory
                ;;
# gnome terminal now waits if invoked as x-terminal-emulator
#            gnome-terminal.wrapper)
#                termcmd=(gnome-terminal --wait -t "$title" --) # gnome-terminal.wrapper does not support --wait
#                ;;
            tilix.wrapper)
                termcmd=(tilix --new-process -t "$title" -e) # tilix.wrapper does not support --new-process
                ;;
            qterminal|terminology)
                echo "$badterm_msg" >&2
                return 1
                ;;
            *)
                termcmd=(x-terminal-emulator -T "$title" -e) # the normal case
                ;;
        esac

        "${termcmd[@]}" bash -c '"$@"; echo -e "\nPress any key to close"; read -srn1' _ "${diffcmd[@]}"
    fi
}

########################################################################
######## Main BLOB list display function ###############################
# sets globals THEMEPATH and BKP_SFX (via restoreSettings) for restore functions
function displayBlobs(){
    local DLGWIDTH DLGHEIGHT DLGARR RET CONFIG CURRENTSESSDIR themename SYSDIRTXT TEXT difflist userfile
    getActiveMonitorDimensions
    while true ;do
        UpdateDisplayDialog # generates DLGARR aand CURRENTSESSDIR
        CONFIG=$(yad "${yad_args[@]}" --list --title="$TITLE" \
            --text="Double-click the highlighted selection, or use \"Enter\" key, or the \"Use Selected Blob\" button to apply selected blob\n" \
            --separator=" " \
            --button="_Save Current Blob:3" --button="_View Selected Blob:4" \
            --button="_Use Selected Blob:0" --button="_Delete Selected Blob:2" \
            --button="_About:5" --button="gtk-quit:1" \
            --always-print-result \
            --width=$DLGWIDTH --height=$DLGHEIGHT --center --image-preview \
            --expand-column=3 \
            --column="Last Set:IMG" \
            --column="Config Name":TEXT \
            --column="Screenshot":IMG \
            "${DLGARR[@]}" \
            2>/dev/null )
        RET=$?
        if [[ $CONFIG =~ '<big>'(.+)'</big>' ]];then
            themename=${BASH_REMATCH[1]}
             # If same name found, user directory will take precedence.
            if [[ -d "$USRCONFIGPATH/$themename" ]]
            then
                THEMEPATH="$USRCONFIGPATH/$themename"
            elif [[ -d "$SYSCONFIGPATH/$themename" ]]
            then
                THEMEPATH="$SYSCONFIGPATH/$themename"
            else
                msg="cannot find BLOB theme $themename"
                echo "$0: $msg" >&2
                yad_fatal_error "$msg"
                exit 1
            fi
        else
            msg="function displayBlobs returned strange value $CONFIG"
            echo "$0: $msg" >&2
            exit 1
        fi

        case $RET in
            0)  sameFiles "$CURRENTSESSDIR/user" "$HOME" || {
                    while true; do
                        if [[ -d $CURRENTSESSDIR ]]; then
                            TEXT="You might have modified your desktop appearance since it was saved as <b>${CURRENTSESSION}</b>.
These files are now different:
 ${difflist[*]/%/\\n}
Do you want to save your current session before restoring <b>${themename}</b>?"
                            yad_question "$TEXT" --button='Save settings first':2 --button='No, restore now':0 --button='View difference(s)':3 --button='Cancel':1
                        else
                            TEXT="You do not seem to have saved your current desktop appearance.
Do you want to save your current session before restoring <b>${themename}</b>?"
                            yad_question "$TEXT" --button='Save settings first':2 --button='No, restore now':0 --button='Cancel':1
                        fi
                        case $? in
                            0)
                                debug "\n Some changed user files, but restoring $themename anyway."
                                break
                            ;;
                            1)
                                debug "\n Cancelled restoring of $themename"
                                continue 2
                            ;;
                            2)
                                debug "\n Saving current desktop settings before restoring $themename"
                                saveNewBlob || debug "Current settings were not saved."
                                break
                            ;;
                            3)
                                debug "\n Showing file differences"
                                for userfile in "${difflist[@]}"; do
                                    differ --title "Changes in user files" "$CURRENTSESSDIR/user/${userfile#$HOME/}" "$userfile"
                                done
                            ;;
                        esac
                    done
                }
#                SAVED="$THEMEPATH/LISTMSG.txt"
#                TEXT="These configs saved as $CONFIG can be restored:\n\n"
#                TEXT="$TEXT$(< "$SAVED")"
#                yad_prompt "$TEXT" || continue
                debug "\n Restoring BLOB theme $themename"
                restoreSettings
                ;;
            1)  exit 0
                ;;
            2)  if [[ ! $CONFIG ]];then
                    if yad_prompt "Make a selection before trying to delete" "$EXIT" "$OK"
                    then
                        continue
                    else
                        exit 0
                    fi
                fi

                SYSDIRTXT="Sorry, system preset theme <b>${themename}</b> cannot be deleted"
                if [[ "${THEMEPATH%/*}" = "$SYSCONFIGPATH" ]]
                then
                    yad_warning "$SYSDIRTXT"
                    continue
                fi

                TEXT="Delete saved configurations <b>$THEMEPATH</b>\nand screenshot?"
                if yad_prompt "$TEXT"
                then
                    rm -rf "$THEMEPATH"
                    debug "\n$themename DELETED"
                    if [[ $(< "$CURSESSFILE") = "$themename" ]];then
                        :> "$CURSESSFILE"
                    fi
                fi
                ;;
            3)  saveNewBlob || debug "Settings were not saved"
                ;;
            4)  # show screenshot in image viewer
                if [[ -n $themename ]];then
                    if [[ -r "$THEMEPATH/${themename}.jpg" ]]; then
                        img="$THEMEPATH/${themename}.jpg"
                    elif [[ -r "${THEMEPATH%/*}/${themename}.jpg" ]]; then
                        img="${THEMEPATH%/*}/${themename}.jpg"
                    else
                        echo "$0: No screenshot ${themename}.jpg found" >&2
                        continue
                    fi
                    $IMGCMD "$img"
                else
                    yad_prompt "Make a selection" "$OK"
                fi
                ;;
            5)  Intro
                ;;
            *)  if (( RET == 252 ));then
                    echo "$0:  Exited with \"ESC\" key" >&2
                else
                    echo "$0:  Error= $RET" >&2
                fi
                exit 1
                ;;
        esac
    done
}

################### end restore functions ##############################

function cleanup(){
    if [[ $1 = all ]];then
        if [[ -d $CONFIGDIR ]];then
            rm -rf "$CONFIGDIR"
            debug "\n  Deleted $CONFIGDIR"
        fi
        if [[ -d $CONFIGDIR_BKP ]];then
            mv "$CONFIGDIR_BKP" "$CONFIGDIR"
            debug "\n  Cancelled\n..Backup $CONFIGDIR restored\n"
        fi
        rm -f /tmp/blob.*
    elif [[ $1 = save ]];then
        saveSettings
    fi
}


###################### END FUNCTIONS ###################################

# add this where an error should trigger a warning, optional exit:
#trap 'trap_error $LINENO "$BASH_COMMAND"' ERR
# to remove trap:
#trap - ERR

# check not running as root, test for openbox session startup file
# sets OBSESSION
firstChecks

# test for blobthemes config directory, create if it doesn't exist
mkdir -p "$USRCONFIGPATH"

# create file to hold most recent saved configuration name
if [[ ! -f $CURSESSFILE ]];then
    touch "$CURSESSFILE"
fi

# convert config filepaths in any existing user saved BLOBs to new scheme
# store conky and tint2 commands in session files
upgradeBlobs

Intro --one-view-only

exit 0
