#!/bin/bash
#
#    bl-obthemes: script to save or restore openbox gui configurations
#    Copyright (C) 2015-2017 damo    <damo@bunsenlabs.org>
#                  2018-2020 John Crawley <john@bunsenlabs.org>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#
# Save options are for  Conky(s)
#                       Tint2(s)
#                       Openbox theme
#                       GTK theme
#                       Background (uses Nitrogen or feh, depending which
#                                   has the newer saved bg config file)
#                       Alt Menu (dmenu)
#                       Lightdm login gtk greeter
#                       X configs (.bashrc, .Xresources)
#                       Terminal emulator config
#
# Paths are assumed to be BunsenLabs defaults
#
# A Screenshot is saved (Windows are hidden briefly so the image
#                        is the bare desktop, with any Tint2s
#                        or Conkys which are running, and a representive
#                        menu and window open)
#
# A time-stamped backup of rc.xml is saved "just in case".
#
# USER VARIABLE: xdotool is used to move the mouse pointer, and assumes the
# root-menu is shown with "Super + Space" keys, and the right mouse button is
# set for "r-click". If you have set these to something else, then edit the
# "MENUMODIFIER" variable and "MOUSECMD" array.
# Set the variable "KEYDOWN" to where "Preferences" is in the root-menu (or
# anything else you might want displayed).
# The image viewer is set to be "bl-image-viewer". Edit the "IMGCMD" variable
# to change this.
#
# WARNING: It is assumed that the conkys are not being run via a script, so
# they will appear on all desktops. If you usually use a script, then you
# may have to make your own arrangements! Conkys in non-default directories
# can be saved, but will not be seen when running the bl conky chooser
#
########################################################################
#
# KNOWN ISSUES:
# Virtualbox does not allow the guest to move the host mouse cursor, using xdotool,
# so the screenshot may produce an incorrect theme displayed and/or poor positioning.
# A workaround is to move the cursor to some free space, and use the "Enter" key in the
# "Configurations to be saved:" dialog.
#

HELP="bl-obthemes is a script to save or restore openbox gui configurations

Usage:  $0 [-h|--help][-v|--verbose]
Options:
        -h, --help      show this message
        -v, --verbose   describe actions being performed
No other CLI options are supported.

Save options:
            Conky(s)

            Tint2(s)

            Openbox theme

            GTK theme

            Background
            (uses Nitrogen or feh, depending which has the newer saved bg config file)

            Alt Menu (dmenu)

            Lightdm login gtk greeter

            X configs (.bashrc, .Xresources)

            Terminal emulator config (if available)

Paths are assumed to be BunsenLabs defaults.

A Screenshot is saved
                    (Windows are hidden briefly so the image
                    is the bare desktop, with any Tint2s
                    or Conkys which are running, and a representive
                    menu and window open.)

A time-stamped backup of rc.xml is saved \"just in case\".

Configuration:

 USER VARIABLE: xdotool is used to move the mouse pointer, and assumes the
 root-menu is shown with \"Super + Space\" keys, and the right mouse button is
 set for \"r-click\". If you have set these to something else, then edit the
 \"MENUMODIFIER\" variable and \"MOUSECMD\" array.
 Set the variable \"KEYDOWN\" to where \"Preferences\" is in the root-menu (or
 anything else you might want displayed).
 The image viewer is set to be \"bl-image-viewer\". Edit the \"IMGCMD\" variable
 to change this.

WARNING:
 It is assumed that the conkys are not being run via a script, so
 they will appear on all desktops. If you usually use a script, then you
 may have to make your own arrangements! Conkys in non-default directories
 can be saved, but will not be seen when running the bl conky chooser.

KNOWN ISSUES:
 Virtualbox does not allow the guest to move the host mouse cursor, using xdotool,
 so the screenshot may produce an incorrect theme displayed and/or poor positioning.
 A workaround is to move the cursor to some free space, and use the \"Enter\" key in the
 \"Configurations to be saved:\" dialog.
"

debug() { : ;}
for i in "$@"
do
    case "$i" in
    -h|--help)
        echo "$HELP"
        exit 0
        ;;
    -v|--verbose)
        debug() {
            echo -e "$*"
        }
        ;;
    esac
done

######################### VARIABLES ####################################

### USER SETTINGS
IMGCMD="bl-image-viewer"    # application command to view screenshot
MENUMODIFIER="super+space"  # keybind for show root-menu
MOUSECMD=(click 3)          # mouse r-click
KEYDOWN=11           # adjust this for where "Preferences" is in the menu

### GLOBALS
USRCONFIGPATH="$HOME/.config/blob"
SYSCONFIGPATH="/usr/share/bunsen/utilities/blob"
CURSESSFILE="$USRCONFIGPATH/current"
OBPATH="$HOME/.config/openbox"
RCFILE="$OBPATH/bl-rc.xml" # NB now using the new BunsenLabs file name
OLDRCFILE="$OBPATH/rc.xml"
CONKYPATH="$HOME/.config/conky"
CONKYSESSION="$CONKYPATH/conky-sessionfile"
TINTSESSION="$HOME/.config/tint2/tint2-sessionfile"

### USER CONFIG VARIABLES TO BE SAVED AND RESTORED
GTK2=".gtkrc-2.0"
GTK2MINE=".gtkrc-2.0.mine"
GTK3=".config/gtk-3.0"
GTK3x=".config/xfce4/xfconf/xfce-perchannel-xml/xfce4-notifyd.xml"
FEHFILE=".fehbg"
NITROFILE=".config/nitrogen/bg-saved.cfg"
DMENU=".config/dmenu/dmenu-bind.sh"
XFILE=".Xresources"
BASHFILE=".bashrc"
#TERMFILE='' # now termfile is set dynamically by checkTerm() in saveSettings()

### SYSTEM CONFIG VARIABLES TO BE SAVED AND RESTORED
LDMDIR="/etc/lightdm"
LDM="lightdm-gtk-greeter.conf"

### END CONFIGS VARIABLES

# packages needed for particular GTK themes
declare -A theme_pkgs=(
[Beam]=bunsen-themes
[Beam-HiDPI]=bunsen-themes
[BL-Fever_Room]=bunsen-themes
[BL-Lithium]=bunsen-themes
[BL-Lithium-light]=bunsen-themes
[Bunsen-He-flatish]=bunsen-themes
)

# packages needed for particular icon themes
declare -A icon_pkgs=(
[Faenza-Dark-Bunsen]='bunsen-faenza-icon-theme'
[Faenza-Bunsen]='bunsen-faenza-icon-theme'
[Paper-Bunsen]='bunsen-paper-icon-theme'
[Papirus-Bunsen-grey]='bunsen-papirus-icon-theme'
[Papirus-Bunsen-bluegrey]='bunsen-papirus-icon-theme'
[Papirus-Bunsen-Dark-grey]='bunsen-papirus-icon-theme'
[Papirus-Bunsen-Dark-bluegrey]='bunsen-papirus-icon-theme'
)

###

THEMEPATH_1="$HOME/.themes"
THEMEPATH_2="$HOME/.local/share/themes"
THEMEPATH_3="/usr/share/themes"
THEMEPATH_4="/usr/local/share/themes"
gtkPaths=("$THEMEPATH_1" "$THEMEPATH_2" "$THEMEPATH_3" "$THEMEPATH_4")

ICONPATH_1="$HOME/.icons"
ICONPATH_2="$HOME/.local/share/icons"
ICONPATH_3="/usr/share/icons"
ICONPATH_4="/usr/local/share/icons"
iconPaths=("$ICONPATH_1" "$ICONPATH_2" "$ICONPATH_3" "$ICONPATH_4")


### DIALOG VARIABLES
TITLE="BLOB Configuration Manager"
ICON="distributor-logo-bunsenlabs"
#DIALOG="yad --center --undecorated --borders=20 --window-icon=distributor-logo-bunsenlabs --fixed"
#DIALOGDEC="yad --center  --borders=20 --window-icon=$ICON"
yad_args=( '--center'  '--borders=20' "--window-icon=$ICON" )
popup_args=( "${yad_args[@]}" "--title=$TITLE" '--undecorated' '--fixed' )
T="--text="
OK="--button=OK:0"
CANCEL="--button=gtk-cancel:1"
EXIT="--button=gtk-quit:1"
CLOSE="--button=gtk-close:1"

PICKOB="OB theme"
PICKGTK="GTK theme"
PICKICONS="Icon theme"
PICKBG="Background Wallpaper"
PICKCONKY="Conky"
PICKTINT="Tint2"
PICKDMENU="dmenu (Alt menu)"
PICKLDM="Lightdm Login theme"
#PICKEXIT="Exit dialog theme"
#PICKTERM='' # now not global, pickterm is from checkTerm(), local in saveSettings()
PICKX="X configs"

### END DIALOG VARIABLES

####################### END VARIABLES ##################################


######################### FUNCTIONS ####################################

### DIALOG FUNCTIONS

# yad displays cancel & OK buttons by default
# --button=* arguments will overrule this default

# arbitary options (eg --entry) can be passed *after* the text
yad_prompt() {
    yad "${popup_args[@]}" --text="$1" --width=300 "${@:2}"
}

yad_question() {
    yad "${popup_args[@]}" --text="$1" \
    --image="dialog-question" --width=300 "${@:2}"
}

yad_warning() {
    yad "${popup_args[@]}" --text="$1" \
    --image="dialog-warning" --width=300 "$CLOSE"
}

yad_fatal_error() {
    yad "${popup_args[@]}" --text="$1" \
    --image="dialog-error" --width=300 "$EXIT"
}

### END DIALOG FUNCTIONS

# trap will pass the line number where the error ocurred as $1
trap_error_exit(){
    local msg="An error ocurred on line ${1}.\nPlease report this to the developers!"
    echo -e "$0: $msg" >&2
    yad_fatal_error "$msg"
    exit 1
}

function upgradeBlobs(){
    moveFile(){ # $1 is file, $2 is target dir
        [[ -f "$2/${1##*/}" ]] && return 0
        [[ -f "$1" ]] || {
            echo "$0: Upgrading ${i}: WARNING Cannot move file ${1}, it does not exist" >&2
            return 1
        }
        mkdir -p "$2"
        mv "$1" "$2" || exit
    }
    moveDir(){
        [[ -d "$2/${1##*/}" ]] && return 0
        [[ -d "$1" ]] || {
            echo "$0: Upgrading ${i}: WARNING Cannot move directory ${1}, it does not exist" >&2
            return 1
        }
        mkdir -p "$2"
        mv "$1" "$2" || exit
    }
    for i in "$USRCONFIGPATH"/*; do
        [[ -d $i ]] || continue
        mkdir -p "$i/user"
        local themename=${i##*/}
        moveFile "$USRCONFIGPATH/${themename}.jpg" "$i"
        :> "$i/newsettings"
        while read -r TAG VAL; do
            home_marker='%USERHOME%'
            case "$TAG" in
                "[TINT2]"       )   printf '%s %s\n' "$TAG" "$VAL" >> "$i/newsettings"
                                    ;;
                "[CONKY]"       )   printf '%s %s\n' "$TAG" "$VAL" >> "$i/newsettings"
                                    ;;
                "[ICONS]"       )   printf '%s %s\n' "$TAG" "$VAL" >> "$i/newsettings"
                                    ;;
                "[GTK]"         )   moveFile "$i/.gtkrc-2.0" "$i/user"
                                    moveFile "$i/.gtkrc-2.0.mine" "$i/user"
                                    moveFile "$i/xfce4-notifyd.xml" "$i/user/.config/xfce4/xfconf/xfce-perchannel-xml"
                                    moveDir "$i/gtk-3.0" "$i/user/.config"
                                    printf '%s %s\n' "$TAG" "$VAL" >> "$i/newsettings"
                                    ;;
                "[OBTHEME]"     )   printf '%s %s\n' "$TAG" "$VAL" >> "$i/newsettings"
                                    ;;
                "[BACKGROUND]"  )   if [[ $VAL = FEH ]];then
                                        moveFile "$i/.fehbg" "$i/user"
                                    else
                                        moveFile "$i/bg-saved.cfg" "$i/user/.config/nitrogen"
                                    fi
                                    printf '%s %s\n' "$TAG" "$VAL" >> "$i/newsettings"
                                    ;;
                "[DMENU]"       )   moveFile "$i/dmenu-bind.sh" "$i/user/.config/dmenu"
                                    printf '%s %s\n' "$TAG" "$VAL" >> "$i/newsettings"
                                    ;;
                "[LIGHTDM]"     )   printf '%s %s\n' "$TAG" "$VAL" >> "$i/newsettings"
                                    ;;
                "[EXITRC]"      )   printf '%s %s\n' "$TAG" "$VAL" >> "$i/newsettings"
                                    ;;
                "[XFILES]"      )   moveFile "$i/.Xresources" "$i/user"
                                    moveFile "$i/.bashrc" "$i/user"
                                    printf '%s %s\n' "$TAG" "$VAL" >> "$i/newsettings"
                                    ;;
                "[TERMINATOR]"  )   moveFile "$i/config" "$i/user/.config/terminator"
                                    printf '%s %s\n' '[Terminator]' '.config/terminator/config' >> "$i/newsettings"
                                    ;;
                '['*']'         )   printf '%s %s\n' "$TAG" "$VAL" >> "$i/newsettings"
                                    ;;
                *               )   echo -e "Upgrading ${i}: ${TAG}:  Unknown value!" >&2
                                    continue
                                    ;;
            esac
        done < "$i/settings.cfg"
        mv -f "$i/newsettings" "$i/settings.cfg"
    done
}

# Kill only with exact match, and only if process belongs to executor.
# Usage: safeKill <processname>
function safeKill() {
    pkill -x -u "$USER" "$1"
}

# sets globals NUMDIRS and CURRENTSESSION
function getCurrent(){      # get name of currently set BLOB config
    local dirs
    NUMDIRS=0
    shopt -s nullglob
    dirs=( "$USRCONFIGPATH"/*/ "$SYSCONFIGPATH"/*/ )
    NUMDIRS=${#dirs[@]}
    shopt -u nullglob
    if (( NUMDIRS == 0 ));then
        if [[ -f $CURSESSFILE ]];then
            rm "$CURSESSFILE"
        fi
    elif (( NUMDIRS > 0 )) && [[ -f $CURSESSFILE ]];then
        CURRENTSESSION=$(< "$CURSESSFILE")
    fi
}

function Intro(){
    TXTINTRO='<big><b>BunsenLabs
Openbox Configuration Manager</b></big>


<b>Save or Restore settings for:</b>

    Openbox theme
    GTK theme
    Conkys
    Tint2
    Desktop Background
    Alt Menu (dmenu)
    LightDM theme
    X configs (.bashrc, .Xresources)
    Terminal (if config file exists)
    + Screenshot'

    debug 'Welcome to BLOB!'

    getCurrent # generates NUMDIRS
    #  if blob/ is empty, then don't display "View Saved" option in Intro dialog
    if (( NUMDIRS > 0 ));then
        yad "${yad_args[@]}" "$T$TXTINTRO" \
        --title="$TITLE" --borders=30 \
        --button="Save Settings:0" --button="View Saved:2" $CLOSE

    else
        yad "${yad_args[@]}" "$T$TXTINTRO" \
        --title="$TITLE" --borders=30 \
        --button="Save Settings:0" $CLOSE

    fi
    case $? in
        0)  saveNewBlob
            displayBlobs
            ;;
        1)  debug "CANCELLED..."
            exit 0
            ;;
        2)  displayBlobs
            ;;
        *)  echo "RETURN ERROR" >&2
            exit 1
            ;;
    esac
}

####################### save functions #################################

# sets globals CONFIGDIR CONFIGDIR_BKP SETTINGS LISTMSG NEWNAME for storing new theme
function setName(){  # set name of collection, make dir and session settings file
    local msg msg2
    msg="  Configurations will be saved to a new directory in  \
    \n  $USRCONFIGPATH\n\n  Enter name of new collection...  "
    msg2="  No file specified for new saved session.\n\n  Try again?"
    local del time txt
    del=0
    while true;do  # loop dialog if nothing is selected
        NEWNAME=$( yad_prompt "$msg" --entry )
        if (( $? == 1 )) ;then # Cancel was selected
            return 1
        elif [[ ! $NEWNAME ]] ;then     # entry was empty
            debug "\n  No name entered for new collection!"
            yad_question "$msg2"
            RET=$?
            if (( RET == 0 ));then
                continue
            else
                return 1
            fi
        else
            NEWNAME=${NEWNAME// /_}    # replace any spaces in dir name
            CONFIGDIR="$USRCONFIGPATH/$NEWNAME"
            CONFIGDIR_BKP="${CONFIGDIR}.bkp"
            if [[ -d $CONFIGDIR ]];then
                debug "\n  $CONFIGDIR already exists"
                if yad_question "Overwrite existing saved session?"
                then
                    mv "$CONFIGDIR" "$CONFIGDIR_BKP" # && mkdir -p "$CONFIGDIR"
                    del=1
                else
                    continue
                fi
            fi
            mkdir -p "$CONFIGDIR" || return 1
            SETTINGS="$CONFIGDIR/settings.cfg"
            LISTMSG="$CONFIGDIR/LISTMSG.txt"
            :> "$SETTINGS"
            :> "$LISTMSG"
            break
        fi
    done
    time=$(date)
    if (( del == 1 ));then
        txt="  (Existing session overwritten)"
    else
        txt=""
    fi
    debug "\n  Configuration will be saved as: $NEWNAME$txt"

#     store list in listfile
    echo -e "<b>Configuration name: $NEWNAME</b>\t$txt\nSaved at $time\n" >> "$LISTMSG"
}

# $1 [$2...] are relative paths passed from save functions
# Save user config file to corresponding directory in $CONFIGDIR/user.
# CONFIGDIR is global set by setName()
function saveFiles(){
    for i in "$@"
    do
        local src_file target_file
        src_file="$HOME/$i"
        target_file="$CONFIGDIR/user/$i"
        saveFileAbs "$src_file" "$target_file" || return 1
    done
}


# $1 and $2 are absolute source and target filepaths
# target should be inside newly created CONFIGDIR
# if source is directory it is saved recursively
function saveFileAbs(){
    local src_file target_file target_dir
    src_file="$1"
    target_file="$2"
    target_dir="${target_file%/*}"
    [[ $target_file = $CONFIGDIR/* ]] || {
        echo "$0: Target is not inside $CONFIGDIR" >&2
        return 1
    }
    [[ -r $src_file ]] || {
        echo "$0: Cannot read source file $src_file" >&2
        return 1
    }
    mkdir -p "$target_dir" || return 1
    if [[ -d $src_file ]];then
        cp -r "$src_file" "$target_file" || return 1
        debug "directory $src_file and contents saved to $target_dir"
    else
        cp "$src_file" "$target_file" || return 1
        debug "file $src_file saved to $target_dir"
    fi
}

# CONFIGDIR is global set by setName()
function saveDconf(){ # passed dconf directory as #1 and name of app (for dumpfile) as $2
    local dconfdir appname dumpfile
    dconfdir=$1
    appname=$2
    mkdir -p "$CONFIGDIR/dconf" || return 1
    dumpfile="$CONFIGDIR/dconf/${appname// /_}" # remove any spaces from name
    dconf dump "$dconfdir" > "$dumpfile" || return 1
    if [[ -s $dumpfile ]]
    then
        debug "Saved dconf $dconfdir to $dumpfile"
    elif [[ -e $dumpfile ]]
    then
        debug "dconf $dconfdir is default, created empty file $dumpfile"
    else
        "$0: failed to create $dumpfile" >&2
        return 1
    fi
}

function getBg(){    # find if feh or nitrogen was used. Save config file(s)
    if [[ -e $HOME/$NITROFILE ]] && [[ -e $HOME/$FEHFILE ]];then  # see which was last used to set background
        if [[ $HOME/$NITROFILE -nt $HOME/$FEHFILE ]];then # use most recent method
            BGSET="NITROGEN"
        else
            BGSET="FEH"
        fi
    elif [[ -e $HOME/$FEHFILE ]];then  # use feh for background
        BGSET="FEH"
    elif [[ -e $HOME/$NITROFILE ]];then    # use nitrogen for background
        BGSET="NITROGEN"
    else
        echo "$0:  No background-setting application found" >&2
        BGSET="None"
    fi
    debug "\n  Background to be set with $BGSET"
    case "$BGSET" in
        FEH     )   saveFiles "$FEHFILE"
                    getFeh
                    ;;
        NITROGEN)   saveFiles "$NITROFILE"
                    getNitrogen
                    ;;
        None    )   echo "$0: No background-setting application found" >&2
                    ;;
    esac
    echo "[BACKGROUND] $BGSET" >> "$SETTINGS"
}

# FEHFILE is config global
# CONFIGDIR is global set by setName()
function getFeh(){    # get Feh saved backgrounds
    local ffile="$CONFIGDIR/user/$FEHFILE"
    if [[ -f $ffile ]];then
        local BG=""
        # get fields between single quotes
        while read -r line;do
            BG="$BG$line;\n\t"
        done < <(grep -o "'[^']*'" "$ffile" | sed "s/'//g" 2>/dev/null)
        debug "\n  Backgrounds set with Feh, using:\t$FEHFILE"
        debug "\t$BG"
        echo -e "Background set with feh:\n\t$BG" >> "$LISTMSG"
    else
        echo "$0:  $ffile not found" >&2
    fi
}

# NITROFILE is config global
# CONFIGDIR is global set by setName()
function getNitrogen(){  # get Nitrogen saved backgrounds
    local NFILE="$CONFIGDIR/user/$NITROFILE"
    if [[ -f $NFILE ]];then
        local BG=""
        while read -r line;do
            [[ $line = 'file='* ]] || continue
            BG="$BG${line#file=};\n\t"
        done < "$NFILE"
        debug "\n  Backgrounds set with Nitrogen, using:\t$CONFIGDIR/user/$NITROFILE"
        debug "\t$BG"
        echo -e "Background set with nitrogen:\n\t$BG" >> "$LISTMSG"
    else
        echo "$0:  $NFILE not found" >&2
    fi
}

# generates command array idCmd from window id (hex or decimal)
# WARNING WM_COMMAND is deprecated: https://www.x.org/releases/X11R7.6/doc/xorg-docs/specs/ICCCM/icccm.html#obsolete_session_manager_conventions
# Usage: getIdCmd <id>
# called in getConky()
function getIdCmd(){
    local wmc del s
    wmc=$(xprop -id "$1"  WM_COMMAND)
    wmc=${wmc#*\"} # strip first & last quotes & everything outside
    wmc=${wmc%\"*}
    wmc=${wmc//\\\"/\"} # unescape any inner quotes
    del='", "'
    s=${wmc}${del}
    idCmd=()
    while [[ -n $s ]]
    do
        idCmd+=("${s%%${del}*}")
        s=${s#*${del}}
    done
}

# extracts path to conky config file from idCmd array generated by getIdCmd()
function getCfile(){
    conkyfile=''
    for i in "${!idCmd[@]}"; do
        [[ ${idCmd[i]} = '-c' ]] && { conkyfile="${idCmd[i+1]}"; break;}
    done
}

function getConky(){
    local conkyfile listmsgtxt
    local CONKYCMD=""
    listmsgtxt="Running Conkys:"
    CMDTXT="[CONKY] "
    CONKYTXT=""
    NUM_DESKTOPS=$(xdotool get_num_desktops)
    local -A arrSTICKY
    if [[ $(pidof conky) ]];then
        while read -r id;do  # get all running conky id's
            arrSTICKY["$id"]=1
        done < <(xdotool search --class conky)

        for (( i=0; i<NUM_DESKTOPS; i++ ));do  # get all conkys running on specific desktops
            while read -r id;do
                unset arrSTICKY["$id"] # remove from sticky list
                if ! [[ -z "$id" ]];then
                    getIdCmd "$id" # generates array idCmd
                    getCfile # extract conky config file
                    CONKYCMD=${idCmd[*]} # NB now in string, filepaths with spaces will be broken.
                    if [[ "$CONKYCMD" == "conky" ]] || [[ "$CONKYCMD" == "conky -q" ]];then
                        CONKYTXT="$CONKYTXT\n\tDesktop $i:  Default Conky"
                        debug "Found running default conky"
                    else
                        CONKYTXT="$CONKYTXT\n\tDesktop $i:  $conkyfile"
                        debug "Found running conky file $conkyfile"
                    fi
                    # command to start on specified desktop with wmctrl
                    CONKYCMD="sleep 1 && wmctrl -s $i && $CONKYCMD &;"
                    CMDTXT="$CMDTXT$CONKYCMD"
                fi
            done < <(xdotool search --desktop $i --class conky)
        done

        for id in "${!arrSTICKY[@]}";do  # get commands - we don't need wmctrl for these
            if ! [[ -z "$id" ]];then
                getIdCmd "$id" # generates array idCmd
                getCfile # extract conky config file
                CONKYCMD=${idCmd[*]} # NB now in string, filepaths with spaces will be broken.
                if [[ "$CONKYCMD" == "conky" ]] || [[ "$CONKYCMD" == "conky -q" ]];then
                    CONKYTXT="$CONKYTXT\n\tDefault Conky"
                else
                    CONKYTXT="$CONKYTXT\n\t$conkyfile"
                fi
                CONKYCMD="sleep 1 && $CONKYCMD &;"
                CMDTXT="$CMDTXT$CONKYCMD"
            fi
        done
        echo "$CMDTXT" >> "$SETTINGS"
        echo -e "$listmsgtxt\t$CONKYTXT\n" >> "$LISTMSG"
        debug "\n  Saved running Conky(s)"
    else
        yad_warning "You selected to save Conkys\nbut none are running"
    fi
    }

function getTint(){
    local tpath msg tintcmd listmsgtxt tint
    local -a arrTINT
    if [[ $(pidof tint2) ]];then
        while read -r pid cmd;do
            if [[ ${cmd%% *} == tint2 ]];then
                tpath=$(echo "$cmd" | awk '{print $NF";"}')
                arrTINT+=("$tpath")
            fi
        done < <(pgrep -a -u "$USER" tint2)

#        TXT="Tint2s:\n\n" # TXT seems not to be used?
        msg="Running Tint2s:"
        tintcmd=""
        listmsgtxt=""

        for i in "${arrTINT[@]}";do
#            TXT="$TXT$i"
            tint=${i//;}
            if [[ "$tint" == "tint2" ]];then
                tintcmd="$tintcmd$tint;"
                listmsgtxt="$listmsgtxt\n\tDefault Tint2"
            else
                tintcmd="$tintcmd$tint;"
                listmsgtxt="$listmsgtxt\n\t$tint"
            fi
        done

        echo "[TINT2] $tintcmd" >> "$SETTINGS"
        echo -e "$msg\t$listmsgtxt\n" >> "$LISTMSG"
        debug "\n  Saved running Tint2(s)"
    else
        yad_warning "You selected to save Tint2\nbut none are running"
    fi
}

# global OBTHEME from getOBname()
function getOBtheme(){   # copy <theme> section from rc.xml to obtheme.txt
    [[ -r $RCFILE ]] || RCFILE="$OLDRCFILE"
    tag="theme"
    sed -n "/<$tag>/,/<\/$tag>/p" "$RCFILE" > "$CONFIGDIR/obtheme.txt"
    getOBname
    echo "[OBTHEME] $OBTHEME" >> "$SETTINGS"
    debug "copied Openbox theme (${OBTHEME}) section from $RCFILE"
}

function getOBname(){    # get Openbox theme name, generate OBTHEME
    local txt obfile
    obfile="$CONFIGDIR/obtheme.txt"
    # OBTHEME=$(awk 'NR==2 {print;exit}' "$obfile" | awk -F'[>|<]' '{print $3}')
    # sed command is long, but it's more precise, and a little bit faster than two awk calls
    OBTHEME=$(sed -nr '/<theme>/ {N;s/^[[:blank:]]*<theme>[[:space:]]*<name>([^<]*)<\/name>.*$/\1/p;q}' "$obfile")
    txt="Openbox theme:  $OBTHEME\n"
    debug "\n  Saved $txt"
    echo "$txt" >> "$LISTMSG"
}

function getGTKtheme(){
    saveFiles "$GTK2" "$GTK2MINE" "$GTK3/settings.ini" "$GTK3/gtk.css" "$GTK3x"
    getGTKname
}

function getGTKname(){   # get GTK theme name and Icons name
    local txt
    GTKFILE="$CONFIGDIR/user/$GTK2"
    while read -r line;do
        if [[ $line = *"gtk-theme-name"* ]];then
            GTKTHEME=$(awk -F '"' '{print $2}' <<< "$line")
            echo "[GTK] $GTKTHEME" >> "$SETTINGS"
        fi
        if [[ $line = *"gtk-icon-theme-name"* ]];then
            ICONS=$(awk -F '"' '{print $2}' <<< "$line")
            echo "[ICONS] $ICONS" >> "$SETTINGS"
        fi
    done < "$GTKFILE"
    txt="GTK theme:  $GTKTHEME;  Icon Theme: $ICONS\n"
    debug "\n  Saved $txt"
    echo  "$txt" >> "$LISTMSG"
}

function getDmenu(){
    local txt
    saveFiles "$DMENU"
    txt="dmenu config:  $HOME/$DMENU\n"
    debug "\n  Saved $txt"
    echo "[DMENU]" >> "$SETTINGS"
    echo "$txt" >> "$LISTMSG"
}

function getLightdm(){
    local txt
    saveFileAbs "$LDMDIR/$LDM" "$CONFIGDIR/$LDM"
    txt="Lightdm config:  $LDMDIR/$LDM\n(password will be needed to restore)\n"
    debug "\n  Saved $txt"
    echo "[LIGHTDM]" >> "$SETTINGS"
    echo "$txt" >> "$LISTMSG"
}

# passed pickterm as $1 and termfile as $2 by saveSettings()
function getTerminal(){
    local termname termfile txt
    termname="$1"
    termfile="$2"
    case "$termfile" in # dconf directories get prefixed with %dconf% in checkTerm()
    '%dconf%'*)
        saveDconf "${termfile#'%dconf%'}" "$termname"
        txt="$termname dconf config: ${termfile#'%dconf%'}\n"
        ;;
    *)
        saveFiles "$termfile"
        txt="$termname config:  ~/$termfile\n"
        ;;
    esac
    debug "\n  Saved $txt"
    echo "[$termname] $termfile" >> "$SETTINGS"
    echo "$txt" >> "$LISTMSG"
}

function getXconfig(){
    local txt
    saveFiles "$XFILE" "$BASHFILE"
    txt="X config:  ~/.Xresources; ~/.bashrc; (~/.bashrc will not be auto-restored)\n"
    debug "\n  Saved $txt"
    echo "[XFILES]" >> "$SETTINGS"
    echo "$txt" >> "$LISTMSG"
}

function checkTint2(){   # kill or restart tint2s for screenshot, if necessary
    if [[ $1 = stop ]];then
        if ! grep -q "TINT2" "$SETTINGS" ;then
            tmpTINT=$(mktemp --tmpdir blob.XXXX) # make blank tempfile, to save running tint2 paths
            if [[ $(pidof tint2) ]];then
                pgrep -a -u "$USER" tint2 | while read -r pid cmd;do
                    if [[ ${cmd%% *} = tint2 ]];then
                        echo "$cmd" >> "$tmpTINT"
                    fi
                done
            safeKill tint2
            fi
        fi
    fi
    if [[ $1 = start ]];then
        if [[ -f "$tmpTINT" ]] 2>/dev/null;then
            while read -r line;do
                ($line &) &>/dev/null
                sleep 1s
            done < "$tmpTINT"
            rm -f "$tmpTINT"
        fi
    fi
}

function getWINDOWS(){  # Minimize/Activate windows for scrot. Args= 'min', 'raise', 'all'
    declare -a arrWINDOWS

    xdoFN() { echo "$0: xdoFN() not set" >&2; exit 1; }
    if [[ "$1" == "min" ]];then
        xdoFN() { xdotool windowminimize "$1";}
    elif [[ "$1" == "raise" ]] || [[ "$1" == "all" ]];then
        xdoFN() { xdotool windowactivate --sync "$1";}
    fi

    # get window id's on current desktop, which aren't sticky; convert hexcode to int.
    # add window ids to array, if not conky
    dtop=$(xdotool get_desktop)
    while read -r id dt _
    do
        [[ $dt = "$dtop" ]] || continue
        arrWINDOWS+=($(( id )))
    done < <(wmctrl -l)

    # minimize/activate non-conky windows
    conk="$(xdotool search --desktop "$dtop" --class 'Conky')"
    for win in "${arrWINDOWS[@]}";do
        if ! [[ $win = "$conk" ]];then
            ( xdoFN "$win" ) 2>/dev/null
        fi
    done
    if [[ "$1" == "all" ]];then # activate any hidden conkys
        for CONK in $(xdotool search --class 'Conky');do
            xdotool windowactivate "$CONK" 2>/dev/null
        done
    fi
}

function getScrot(){
    local conkyFLAG currDESKTOP SCROT
    conkyFLAG=1
    currDESKTOP=$(xprop -root _NET_CURRENT_DESKTOP | tail -c -2)
    SCROT="$USRCONFIGPATH/$NEWNAME/${NEWNAME}.jpg"
    MONS=$(xrandr -q | grep -c " connected")    # number of monitors
    # set mouse position, for appearance of root-menu
    screenW=$(xrandr -q | awk '/Screen/ {print $8}')
    screenH=$(xrandr -q | awk '/Screen/ {print $10}')
    screenH=${screenH%,}

    if (( MONS == 1 ));then # single monitor
        appX=$(( (screenW/20)*8 ))
        menuX=$(( (screenW/20)*2 ))
    else
        appX=$(( (screenW/20)*4 ))
        menuX=$(( (screenW/20)*1 ))
    fi
    appY=$(( (screenH/20)*4 ))
    menuY=$(( (screenH/20)*4 ))

    if ! grep "CONKY" "$SETTINGS" &>/dev/null;then    # Conkys not to be saved
        wmctrl -k on    # hide windows, show desktop
        conkyFLAG=0
    else                # Conkys will be saved, so don't hide them for the scrot
        getWINDOWS min  # minimize windows
    fi
    checkTint2 stop     # stop running Tint2s for the scrot, if not selected to be saved
    # start lxappearance
    lxappearance 2>/dev/null &
    sleep 0.5
    # get lx window, make sure it loses focus, then move mouse and start root-menu
    LX=$(xdotool getwindowfocus)
    xdotool windowmove --sync "$LX" "$appX" "$appY" && sleep 0.1 && \
    xdotool mousemove --sync --window "$LX" -- -50 0 && xdotool click 1
    xdotool mousemove --sync "$menuX" "$menuY" && xdotool key --clearmodifiers "$MENUMODIFIER"

    i=1
    while (( i <= KEYDOWN ));do
        xdotool key --delay 50 Down
        i=$(( i+1 ))
    done
    xdotool key --delay 20 Right && sleep 0.3

    # take scrot
    scrot -t 9 "$SCROT"    # scrot thumbnail @9% fullsize

    # close root menu
    xdotool mousemove_relative --sync --polar 0 10 "${MOUSECMD[@]}"
    # kill lxappearance
    pkill -P "$$" lxappearance

    # restore hidden windows
    if (( conkyFLAG == 0 ));then
        getWINDOWS all              # including hidden conkys
    else
        getWINDOWS raise            # Conkys weren't closed for scrot
    fi
    wmctrl -s "$currDESKTOP" # return to desktop that BLOB was started on, if conkys used 'wmctrl -s'
    checkTint2 start                # restore any stopped Tint2s
}

# sets termfile and pickterm, local inside saveSettings()
function checkTerm(){
    case $( readlink /etc/alternatives/x-terminal-emulator ) in
    /usr/bin/lxterminal)
        termfile='.config/lxterminal/lxterminal.conf'
        pickterm='Lxterminal'
        ;;
    /usr/bin/terminator)
        termfile='.config/terminator/config'
        pickterm='Terminator'
        ;;
    /usr/bin/xfce4-terminal.wrapper)
        termfile='.config/xfce4/terminal/terminalrc'
        pickterm='Xfce4-terminal'
        ;;
    /usr/bin/sakura)
        termfile='.config/sakura/sakura.conf'
        pickterm='Sakura'
        ;;
    /usr/bin/gnome-terminal.wrapper)
        termfile='%dconf%/org/gnome/terminal/'
        pickterm='Gnome-terminal'
        ;;
    /usr/bin/mate-terminal.wrapper)
        termfile='%dconf%/org/mate/terminal/'
        pickterm='Mate-terminal'
        ;;
    /usr/bin/tilix.wrapper)
        termfile='%dconf%/com/gexperts/Tilix/'
        pickterm='Tilix'
        ;;
    *)
        termfile=''
        ;;
    esac
}

function saveSettings(){
    local configs termfile pickterm txt txt2
    configs=(
        "$PICKOB"
        "$PICKGTK"
        "$PICKBG"
        "$PICKCONKY"
        "$PICKTINT"
        "$PICKDMENU"
        "$PICKLDM"
        "$PICKX"
    )
    debug "Saving current configs as \"$NEWNAME\""
    checkTerm # sets termfile and pickterm
    # add terminal to array if one with a config file is in use
    if  [[ -n $termfile ]];then
        configs+=("$pickterm")
    fi
    for item in "${configs[@]}";do # now saving all configs
        case "$item" in
            "$PICKOB"   )   getOBtheme
                            ;;
            "$PICKGTK"  )   getGTKtheme
                            ;;
            "$PICKBG"   )   getBg
                            ;;
            "$PICKCONKY")   getConky
                            ;;
            "$PICKTINT" )   getTint
                            ;;
            "$PICKDMENU")   getDmenu
                            ;;
            "$PICKLDM"  )   getLightdm
                            ;;
            "$PICKX"    )   getXconfig
                            ;;
            "$pickterm" )   getTerminal "$pickterm" "$termfile"
                            ;;
            *           )   echo "$0:  Unknown config value in saveSettings function" >&2
                            exit 1
                            ;;
        esac
    done
    txt="<big><b><u>Openbox Configurations to be saved:</u></b></big>\n\n"
    txt2=$(cat "$LISTMSG")
    yad_prompt "$txt$txt2"
    ret=$?
    if (( ret == 1 ));then
        cleanup all
        return 1
    else
        echo "$NEWNAME" > "$CURSESSFILE"     # replace entry in saved config flag file
    fi
}

###################### end save functions ##############################

###################### restore functions ###############################

function checkICONS(){ # check if icon theme is still present
    local FOUNDICONS=0
    local ICOTXT="Icon theme <b>$1</b> not found\n\n  The default icon theme will be used..."
    for i in "${iconPaths[@]}";do # iconPaths defined at top
        if [[ -d "$i/$1" ]];then
            debug "\n  Found $1 icon theme"
            FOUNDICONS=1
            break
        fi
    done
    if (( FOUNDICONS == 0 ));then
        local pkg="${icon_pkgs[$1]}"
        if [[ -n "${pkg}" ]] && hash bl-install >/dev/null
        then
            debug "\n  Icon theme  $1  was not found\n  Offering to install $pkg..."
            local INSTICOTXT="Needed icon theme <b>$1</b> not found\n Would you like to install the package <b>${pkg}</b> which contains that theme?"
            if yad_question "$INSTICOTXT"
            then
                local retfile retval
                retfile="$( mktemp )"
                bl-install -f "$retfile" "$pkg"
                wait $!
                retval="$(<"$retfile")"
                rm "$retfile"
                if [[ "$retval" = 0 ]]
                then
                    return 0
                else
                    yad_warning "Package install failed."
                fi
            fi
        fi
        debug "\n  Icon theme  $1  was not found\n  The default Icon theme will be used..."
        yad_warning "$ICOTXT"
    fi
}

function checkGTK(){    # check if gtk theme is still present
    local INSTGTKTXT="Needed GTK theme <b>$1</b> not found\n Would you like to install the package <b>${pkg}</b> which contains that theme?"
    local NOGTKTXT="GTK theme <b>$1</b> not found\n\n  The default GTK theme will be used..."
    for i in "${gtkPaths[@]}";do # gtkPaths defined at top
        if [[ -d "$i/$1" ]];then
            debug "\n  Found $1 GTK theme"
            return 0
        fi
    done
    local pkg="${theme_pkgs[$1]}"
    if [[ -n "${pkg}" ]] && hash bl-install >/dev/null
    then
        debug "\n  GTK theme  $1  was not found\n  Offering to install $pkg..."
        if yad_question "$INSTGTKTXT"
        then
            local retfile retval
            retfile="$( mktemp )"
            bl-install -f "$retfile" "$pkg"
            retval="$(<"$retfile")"
            rm "$retfile"
            if [[ "$retval" = 0 ]]
            then
                return 0
            else
                yad_warning "Package install failed."
            fi
        fi
    fi
    debug "\n  GTK theme  $1  was not found\n  The default GTK theme will be used..."
    yad_warning "$NOGTKTXT"
    return 1
}

function restoreGTK(){
    restoreFiles "$GTK2" "$GTK2MINE" "$GTK3" "$GTK3x"
    reloadGTK
    restartThunar
}

function reloadGTK(){ # reload gtk theme after restoring saved config
python - <<END
import gtk

events=gtk.gdk.Event(gtk.gdk.CLIENT_EVENT)
data=gtk.gdk.atom_intern("_GTK_READ_RCFILES", False)
events.data_format=8
events.send_event=True
events.message_type=data
events.send_clientmessage_toall()

END
}

function restartThunar(){
    pkill -fx 'thunar[[:blank:]]+--daemon' || return 0
    thunar --daemon & # only restart if it was previously running as daemon
}

function checkOBTHEME(){
    local FOUNDOB=0
    local OBTXT="Openbox theme <b>$1</b> not found\n\n  The default Openbox theme will be used..."
    for i in "${gtkPaths[@]}";do # gtkPaths defined at top
        if [[ -d "$i/$1/openbox-3" ]];then
            debug "\n  Found $1 Openbox theme"
            FOUNDOB=1
            break
        fi
    done
    if (( FOUNDOB == 0 ));then
        debug "\n  OB theme  $1  was not found\n  The default Openbox theme will be used..."
        yad_warning "$OBTXT"
    fi
}

# THEMEPATH and BKP_SFX are globals,
# set by displayBlobs() and restoreSettings() respectively.
function restoreOBrc(){
    THEMEFILE="$THEMEPATH/obtheme.txt"
    FTEMP=$(mktemp --tmpdir blob.XXXX)
    [[ -r $RCFILE ]] || RCFILE="$OLDRCFILE"
    # backup bl-rc.xml first
    RCBKP="${RCFILE}${BKP_SFX}"
    cp "$RCFILE" "$RCBKP"
    # remove older backups
    for f in "$OBPATH"/*.blob.* ;do
        if [[ $f -ot $RCBKP ]];then
            rm "$f"
        fi
    done
    ## put placeholder in place of <theme> section, write to tempfile
    sed -n "/<theme>/{:a;N;/<\/theme>/!ba;N;s/.*\n/THEMESECTION\n/};p" "$RCFILE" > "$FTEMP"
    # replace placeholder from theme file
    sed -i "/THEMESECTION/{
        s/THEMESECTION//g
        r $THEMEFILE
    }" "$FTEMP"
    sed -i '/^$/d' "$FTEMP"   # remove empty lines
    cp "$FTEMP" "$RCFILE"     # overwrite rc.xml
    debug "\n  rc.xml backed up and edited for OB theme"
    openbox --reconfigure && debug "\n Openbox reconfigured"
    hash jgmenu_run 2>/dev/null && JGMENU_RCXML="$RCFILE" jgmenu_run init --apply-obtheme && debug "\n jgmenu reconfigured"
    debug "\n Openbox and jgmenu reconfigured"
    rm -f "$FTEMP"
}

function restoreConky(){    # arg = $VAL from displayBlobs()
    local currDESKTOP CONKYCMD
    currDESKTOP=$(xprop -root _NET_CURRENT_DESKTOP | tail -c -2)   # Conkys may have been started on different desktops
    CONKYCMD="$1"
    if type bl-conky-manager &>/dev/null;then    # see if bl-conky-manager is installed
        if [[ -f $CONKYSESSION ]]; then
            :> "$CONKYSESSION" # create/overwrite conky session file
            # write to conky session file...
            echo "${CONKYCMD//;/$'\n'}" >> "$CONKYSESSION"
            safeKill conky
            source "$CONKYSESSION"  # run conky commands
#            wait
        fi
    else
        safeKill conky
        eval "$CONKYCMD"    # no bl-conky-manager, so just run conky commands
#        wait
    fi
    debug "\n  Restored Conky\n"
    wmctrl -s "$currDESKTOP" && sleep 1 # return to desktop that BLOB was started on, if conkys used 'wmctrl -s'
}

function restoreTint2(){    # arg = $VAL from displayBlobs()
    local tintcmd="${1//;/$'\n'}"
    if type bl-tint2-manager >/dev/null;then    # see if bl-tint2-manager is installed
        if [[ -f $TINTSESSION ]] 2>/dev/null; then
            :> "$TINTSESSION"    # create/overwrite tint2 session file
            # write to tint2 session file...
            echo "$tintcmd" >> "$TINTSESSION"
            safeKill tint2
            while read -r tintline;do
                if [[ "$tintline" == "tint2" ]];then
                    tint2 >/dev/null 2>&1 &
                    sleep 1
                    debug "\n  Restored Tint2: $tintline\n"
                elif [[ -n "$tintline" ]];then
                    tint2 -c "$tintline" >/dev/null 2>&1 &
                    sleep 1s
                    debug "\n  Restored Tint2: $tintline\n"
                fi
            done < "$TINTSESSION"
        fi
    else                    # no bl-tint2-manager, so just run tint2 commands
        safeKill tint2
        for tintpath in $tintcmd;do
            if [[ "$tintpath" == "tint2" ]] >/dev/null;then
                tint2 >/dev/null 2>&1 &     # default tint2 command
                sleep 1
                debug "\n  Restored Tint2: $tintpath\n"
            else
                tint2 -c "$tintpath" >/dev/null 2>&1 &
                sleep 1s
                debug "\n  Restored Tint2: $tintpath\n"
            fi
        done
    fi
}

# THEMEPATH and BKP_SFX are globals,
# set by displayBlobs() and restoreSettings() respectively.
function restoreLightdm(){   # need sudo to restore lightdm-gtk-greeter.conf
    local msg ret
    [[ -r "$THEMEPATH/$LDM" ]] || {
        echo "$0: Cannot read file $THEMEPATH/$LDM" >&2
        return 1
    }
    cmp "$THEMEPATH/$LDM" "$LDMDIR/$LDM" >/dev/null 2>&1 && {
        debug "\n $THEMEPATH/$LDM and $LDMDIR/$LDM are identical, no need to restore."
        return 0
    }
    while true;do
        msg="Please enter your password to edit the system file lightdm-gtk-greeter.conf"
        yad_prompt "$msg" --entry --hide-text | sudo -S cp --backup --suffix="$BKP_SFX" "$THEMEPATH/$LDM" "$LDMDIR/$LDM" 2>/dev/null
        ret=( "${PIPESTATUS[@]}" )
        if [[ ${ret[1]} = 0 ]]
        then
            msg="Restored: lightdm-gtk-greeter.conf"
            debug "\n  $msg"
            return 0
        elif [[ ${ret[0]} = 1 ]]
        then
            msg="Authentication cancelled\n\nlightdm-gtk-greeter.conf was not restored"
            echo "$0: $msg" >&2
            return 1
        else
            msg="Password input failed\n\nlightdm-gtk-greeter.conf was not restored"
            echo "$0: $msg" >&2
            yad_warning "$msg"
        fi
    done
}

# $1 [$2...] are relative paths passed from displayBlobs()
# THEMEPATH is global set by displayBlobs()
# If source is directory, its contents will be copied to the equivalent user directory.
function restoreFiles(){
    local src_file target_file i
    for i in "$@"
    do
        debug "Restoring ${i}..."
        src_file="$THEMEPATH/user/$i"
        target_file="$HOME/$i"
        if [[ -d $src_file ]]; then
            copyDir "$src_file" "$target_file" || return 1
        elif [[ -f $src_file ]]; then
            restoreFileAbs "$src_file" "$target_file" || return 1
        else
            echo "$0: File to restore, $src_file does not exist." >&2
            return 1
        fi
    done
}

# Copy all the contents of a directory, recursively.
# $1 and $2 are absolute paths of source and target directories.
function copyDir(){
    local src_dir target_dir i
    src_dir="$1"
    target_dir="$2"
    if [[ -f $target_dir ]]
    then
        echo "$0: target directory $target_dir is an ordinary file" >&2
        return 1
    fi
    debug "\n  making directory $target_dir"
    mkdir -p "$target_dir" || return 1
    for i in "$src_dir"/*
    do
        [[ -e "$i" ]] || continue
        if [[ -d "$i" ]]
        then
            copyDir "$i" "$target_dir/${i##*/}" || return 1
        else
            restoreFileAbs "$i" "$target_dir/${i##*/}" || return 1
        fi
    done
}

# $1 and $2 are absolute source and target filepaths
# BKP_SFX is global set by restoreSettings()()
function restoreFileAbs(){
    local src_file target_file target_dir bkp_file
    src_file="$1"
    target_file="$2"
    target_dir="${target_file%/*}"
    mkdir -p "$target_dir" || return 1
    if [[ -e $target_file ]];then        # backup config first
        cmp "$src_file" "$target_file" >/dev/null 2>&1 && {
            debug "\n  $target_file and $src_file are identical, no need to restore."
            return 0
        }
        bkp_file="${target_file}${BKP_SFX}"
        mv "$target_file" "$bkp_file" || return 1
        cp "$src_file" "$target_file" || return 1
        debug "\n  $target_file backed up and restored"
    else
        cp "$src_file" "$target_file" || return 1
        debug "\n  $target_file did not exist, now added"
    fi
}

# THEMEPATH and BKP_SFX are globals set by displayBlobs() and restoreSettings() respectively.
# dconfdir and appname passed as $1 and $2 from restoreSettings()
function restoreDconf(){
    local dconfdir appname src_file bkpdir bkp_file current_state blob_state
    dconfdir=$1
    appname=$2
    src_file="$THEMEPATH/dconf/${appname// /_}"
    [[ -f $src_file ]] || {
        echo "$0: cannot find dconf config $src_file for \"$appname\"" >&2
        return 1
    }
    bkpdir="$HOME/.config/dconf-backups"
    bkp_file="$bkpdir/${appname// /_}${BKP_SFX}"
    current_state=$( dconf dump "$dconfdir" ) || return 1
    blob_state=$(< "$src_file" )
    [[ $current_state = "$blob_state" ]] && { # including when both are empty, ie default state
        debug "${appname}: no need to restore dconf, settings are the same."
        return 0
    }
    [[ -n $current_state ]] && {
        mkdir -p "$bkpdir" || return 1
        debug "${appname}: backing up dconf settings to $bkp_file"
        printf '%s\n' "$current_state" > "$bkp_file" || return 1
        dconf reset -f "$dconfdir" || return 1
    }
    [[ -n $blob_state ]] && {
        debug "${appname}: restoring dconf settings from $src_file"
        dconf load "$dconfdir" < "$src_file" || return 1
    }
}
    
# This function is run in displayBlobs() below
# CURRENTSESSION and NUMDIRS from getCurrent()
# DLGARR and CURRENTSESSDIR are local to displayBlobs()
function UpdateDisplayDialog(){   # list saved theme collections for yad as DLGARR
    getCurrent                    # get name of latest set BLOB config
    if (( NUMDIRS == 0 ));then  # no saved configs; go back to Intro dialog
        Intro
    fi
    local seticon themename thumbnail
    declare -A uniqnames # hide duplicate directories
    DLGARR=()
    for dir in "$USRCONFIGPATH"/* "$SYSCONFIGPATH"/* ;do
        [[ -d $dir && -e $dir/settings.cfg ]] || continue
        themename="${dir##*/}" # strip path
        themename=${themename// /_}   # replace any spaces in dir name
        [[ "${uniqnames[$themename]}" = 'found' ]] && continue
        uniqnames["$themename"]='found'
        # get name of current session, set icon for TRUE/FALSE
        if [[ $CURRENTSESSION = "$themename" ]];then
            seticon="gtk-yes"
            CURRENTSESSDIR="$dir"
        elif [[ "$dir" = "$SYSCONFIGPATH"/* ]]; then
            seticon="system"
        else
            seticon="gtk-home"
        fi
        thumbnail="$dir/$themename-thumb.jpg"
        [[ -r $thumbnail ]] || thumbnail='None'     # placeholder if no thumbnail found
        DLGARR+=( "$seticon" "<big>$themename</big>" "$thumbnail" )
    done
}

# This function is run in displayBlobs() below
function getActiveMonitorDimensions(){   # set width and height for View dialog
    declare -a dim=()
    dim=($(bl-xinerama-prop))
    DLGWIDTH=$(( dim[0] / 3 ))
    DLGHEIGHT=$(( dim[1] * 2 / 3 ))
    [[ $DLGWIDTH =~ ^[0-9]+$ ]] && [[ $DLGHEIGHT =~ ^[0-9]+$ ]] || {
        print 'Error in getActiveMonitorDimensions'
        exit 1
    }
}

# This function is run in displayBlobs() below
# global THEMEPATH is set there
restoreSettings() {
    # get chosen saved configs and restore them
    # Conky and Tint2 will be killed by their restore functions, if called.
    BKP_SFX=".blob.$(date +"%Y%m%d-%H%M%S")" # global: unified backup suffix that restore functions will use
    local TAG VAL labels label columns select ret CHOICE
    declare -A values
    while read -r TAG VAL; do
        case "$TAG" in
            "[OBTHEME]"     )   labels+=("$PICKOB")       # Order of associative array values is not defined,
                                values["$PICKOB"]="$VAL"  # but indexed array labels preserves order of settings.cfg.
                                ;;
            "[GTK]"         )   labels+=("$PICKGTK")
                                values["$PICKGTK"]="$VAL"
                                ;;
            "[ICONS]"       )   labels+=("$PICKICONS")
                                values["$PICKICONS"]="$VAL"
                                ;;
            "[BACKGROUND]"  )   labels+=("$PICKBG")
                                values["$PICKBG"]="$VAL"
                                ;;
            "[CONKY]"       )   labels+=("$PICKCONKY")
                                values["$PICKCONKY"]="$VAL"
                                ;;
            "[TINT2]"       )   labels+=("$PICKTINT")
                                values["$PICKTINT"]="$VAL"
                                ;;
            "[DMENU]"       )   labels+=("$PICKDMENU")
                                values["$PICKDMENU"]="$VAL"
                                ;;
            "[LIGHTDM]"     )   labels+=("$PICKLDM")
                                values["$PICKLDM"]="$VAL"
                                ;;
            "[EXITRC]"      )   : # do nothing
                                ;;
            "[XFILES]"      )   labels+=("$PICKX")
                                values["$PICKX"]="$VAL"
                                ;;
            '['*']'         )   TAG="${TAG#[}" # strip outside brackets
                                TAG="${TAG%]}"
                                labels+=("$TAG")
                                values["$TAG"]="$VAL"
                                ;;
            *               )   echo "$0: Ignoring unknown value: ${TAG} in $THEMEPATH/settings.cfg" >&2
                                ;;
        esac
    done < "$THEMEPATH/settings.cfg"

    select='FALSE'
    while true
    do
        columns=()
        for i in "${labels[@]}"
        do
            columns+=("$select" "$i")
        done
        CHOICE=$(yad "${yad_args[@]}" --list --checklist \
            --title="Choose the configs to restore..." \
            --button="Select All:2" $CANCEL $OK \
            --height=400 --width=400 \
            --print-column=2 --separator='' \
            --column="Select" --column="Config" "${columns[@]}" )
        ret=$?
        if (( ret == 1 )); then # cancel button pressed
            cleanup all
            return
        elif (( ret == 2 ));then
            select="TRUE"
            continue
        fi
        if [[ -z $CHOICE ]] ; then # entry field is empty, so try again
            yad_question "\n  Make a selection...." $EXIT $OK
            if (( $? == 1 ));then
                cleanup all
                exit 0
            else
                select='FALSE'
                continue
            fi
        fi
        break
    done

    trap 'trap_error_exit $LINENO' ERR
    # exit if any restore function fails
    # TODO: add 'return 1' to functions as needed

    # Go through user's selected choices.
    home_marker='%USERHOME%'
    while read -r label
    do
        VAL="${values[$label]}"
        debug "\n Restoring $label with $VAL"
        case "$label" in
            "$PICKOB"       )   [[ -n $VAL ]] && checkOBTHEME "$VAL"
                                restoreOBrc
                                ;;
            "$PICKGTK"      )   [[ -n $VAL ]] && checkGTK "$VAL"
                                restoreGTK
                                # reloadGTK now called in restoreGTK
                                ;;
            "$PICKICONS"    )   [[ -n $VAL ]] && checkICONS "$VAL"
                                ;;
            "$PICKBG"       )   if [[ $VAL = FEH ]];then
                                    restoreFiles "$FEHFILE"
                                    source "$HOME/$FEHFILE"
                                else
                                    restoreFiles "$NITROFILE"
                                    nitrogen --restore
                                fi
                                ;;
            "$PICKCONKY"    )   if [[ -n $VAL ]];then
                                    VAL="${VAL//$home_marker/$HOME}"
                                    restoreConky "$VAL"
                                fi
                                ;;
            "$PICKTINT"     )   if [[ -n $VAL ]];then
                                    VAL="${VAL//$home_marker/$HOME}"
                                    restoreTint2 "$VAL"
                                fi
                                ;;
            "$PICKDMENU"    )   restoreFiles "$DMENU"
                                ;;
            "$PICKLDM"      )   restoreLightdm
                                ;;
            "$PICKX"        )   debug ".bashrc will not be overwritten: a copy is in $THEMEPATH/.bashrc"
                                restoreFiles "$XFILE" #"$BASHFILE" # do not restore .bashrc for now
                                xrdb ~/.Xresources
                                ;;
            *               )   if [[ $VAL = '%dconf%'* ]] # dconf directories come prefixed with %dconf% in checkTerm (and others in future?)
                                then
                                    restoreDconf "${VAL#'%dconf%'}" "$label"
                                else
                                    restoreFiles "$VAL"
                                fi
                                ;;
        esac
    done <<< "$CHOICE"
    trap - ERR # remove trap for normal error handling
}

# used in displayBlobs() below
function saveNewBlob() {
    setName || return 1
    debug "\n  Saving settings as $NEWNAME"
    saveSettings 
    getScrot
    yad_prompt "Settings were saved as <b>$NEWNAME</b>" --image="gtk-save" "$OK"
    if [[ -d $CONFIGDIR_BKP ]];then
        rm -rf "$CONFIGDIR_BKP"
        debug "\n  Temporary backup of $CONFIGDIR deleted\n"
    fi
}

# used in displayBlobs() below
# tests if every file in $1 is identical with its equivalent in $2
# (files not present in $2 are ignored)
function sameFiles() {
    local smalldir bigdir dir
    smalldir=$1
    bigdir=$2
    debug "Comparing $smalldir and $bigdir"
    for dir in "$smalldir" "$bigdir"
    do
        [[ -d $dir ]] || {
            echo "$0: ${dir} is not a directory." >&2
            return 1
        }
    done
    shopt -s globstar dotglob
    for file in "$smalldir"/**
    do
        [[ -f $file ]] || continue
        [[ -f ${file/#$smalldir/$bigdir} ]] || continue
        cmp "$file" "${file/#$smalldir/$bigdir}" >/dev/null 2>&1 || {
            debug "Some files in $smalldir are different from those in $bigdir"
            return 1
        }
    done
    shopt -u globstar dotglob
    debug "All files in $smalldir are identical with those in $bigdir"
}

########################################################################
######## Main BLOB list display function ###############################
# sets globals THEMEPATH and BKP_SFX (via restoreSettings) for restore functions
function displayBlobs(){
    local DLGWIDTH DLGHEIGHT DLGARR RET CONFIG CURRENTSESSDIR themename 
    getActiveMonitorDimensions
    while true ;do
        UpdateDisplayDialog # generates DLGARR
        CONFIG=$(yad "${yad_args[@]}" --list --title="$TITLE" \
            --text="Double-click selection, or \"Enter\", or use the \"Restore\" button to restore settings\n" \
            --separator=" " \
            --button="About:5" \
            --button="View image:4" --button="Add New:3" \
            --button="Delete:2" --button="Restore:0" --button="gtk-quit:1" \
            --always-print-result \
            --width=$DLGWIDTH --height=$DLGHEIGHT --center --image-preview \
            --expand-column=3 \
            --column="Last Set:IMG" \
            --column="Config Name":TEXT \
            --column="Screenshot":IMG \
            "${DLGARR[@]}" \
            2>/dev/null )
        RET=$?
        if [[ $CONFIG =~ '<big>'(.+)'</big>' ]];then
            themename=${BASH_REMATCH[1]}
             # If same name found, user directory will take precedence.
            if [[ -d "$USRCONFIGPATH/$themename" ]]
            then
                THEMEPATH="$USRCONFIGPATH/$themename"
            elif [[ -d "$SYSCONFIGPATH/$themename" ]]
            then
                THEMEPATH="$SYSCONFIGPATH/$themename"
            else
                msg="cannot find BLOB theme $themename"
                echo "$0: $msg" >&2
                yad_fatal_error "$msg"
                exit 1
            fi
        else
            msg="function displayBlobs returned strange value $CONFIG"
            echo "$0: $msg" >&2
            exit 1
        fi

        case $RET in
            0)  sameFiles "$CURRENTSESSDIR/user" "$HOME" || {
                    TEXT="You have modified your desktop appearance since it was saved as <b>${CURRENTSESSION}</b>
You might want to save your current session before restoring <b>${themename}</b>,
or some settings might be overwritten.
Save settings first?"              
                    yad_prompt "$TEXT" --image="dialog-warning" --button='Save settings first':2 --button='No, restore now':0 --button='Cancel':1
                    case $? in
                        1)
                            debug "\n Cancelled restoring of $themename"
                            continue
                        ;;
                        2)
                            debug "\n Saving current desktop settings before restoring $themename"
                            saveNewBlob
                        ;;
                    esac
                }   
                SAVED="$THEMEPATH/LISTMSG.txt"
                TEXT="These configs saved as $CONFIG can be restored:\n\n"
                TEXT="$TEXT$(< "$SAVED")"
                yad_prompt "$TEXT" || continue
                debug "\n Restoring BLOB theme $themename"
                echo "$themename" > "$CURSESSFILE"
                restoreSettings
                ;;
            1)  exit 0
                ;;
            2)  if [[ ! $CONFIG ]];then
                    if yad_prompt "Make a selection before trying to delete" "$EXIT" "$OK"
                    then
                        continue
                    else
                        exit 0
                    fi
                fi

                SYSDIRTXT="Sorry, system preset theme <b>${themename}</b> cannot be deleted"
                if [[ "${THEMEPATH%/*}" = "$SYSCONFIGPATH" ]]
                then
                    yad_warning "$SYSDIRTXT"
                    continue
                fi

                TEXT="Delete saved configurations <b>$THEMEPATH</b>\nand screenshot?"
                if yad_prompt "$TEXT"
                then
                    rm -rf "$THEMEPATH"
                    debug "\n$themename DELETED"
                    if [[ $(< "$CURSESSFILE") = "$themename" ]];then
                        :> "$CURSESSFILE"
                    fi
                fi
                ;;
            3)  saveNewBlob
                ;;
            4)  # show screenshot in image viewer
                if [[ -n $themename ]];then
                    if [[ -r "$THEMEPATH/${themename}.jpg" ]]; then
                        img="$THEMEPATH/${themename}.jpg"
                    elif [[ -r "${THEMEPATH%/*}/${themename}.jpg" ]]; then
                        img="${THEMEPATH%/*}/${themename}.jpg"
                    else
                        echo "$0: No screenshot ${themename}.jpg found" >&2
                        continue
                    fi
                    $IMGCMD "$img"
                else
                    yad_prompt "Make a selection" "$OK"
                fi
                ;;
            5)  Intro
                ;;
            *)  if (( RET == 252 ));then
                    echo "$0:  Exited with \"ESC\" key" >&2
                else
                    echo "$0:  Error= $RET" >&2
                fi
                exit 1
                ;;
        esac
    done
}

################### end restore functions ##############################

function cleanup(){
    if [[ $1 = all ]];then
        if [[ -d $CONFIGDIR ]];then
            rm -rf "$CONFIGDIR"
            debug "\n  Deleted $CONFIGDIR"
        fi
        if [[ -d $CONFIGDIR_BKP ]];then
            mv "$CONFIGDIR_BKP" "$CONFIGDIR"
            debug "\n  Cancelled\n..Backup $CONFIGDIR restored\n"
        fi
        rm -f /tmp/blob.*
    elif [[ $1 = save ]];then
        saveSettings
    fi
}


###################### END FUNCTIONS ###################################

# add this where an error should trigger exit:
#trap 'trap_error_exit $LINENO' ERR
# to remove trap:
#trap - ERR

# Do not run as root (Bad Things may happen).
if [[ $( id -u ) -eq 0 ]]; then
    echo $"$0: Error: This script should not be run by root." >&2
    exit 1
fi

# test for blobthemes config directory, create if it doesn't exist
mkdir -p "$USRCONFIGPATH"

# create file to hold most recent saved configuration name
if [[ ! -f $CURSESSFILE ]];then
    touch "$CURSESSFILE"
fi

# convert config filepaths in any existing user saved BLOBs to new scheme
upgradeBlobs

Intro

exit 0
