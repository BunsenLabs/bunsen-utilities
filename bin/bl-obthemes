#!/bin/bash
#
#    bl-obthemes: script to save or restore openbox gui configurations
#    Copyright (C) 2015,2017 damo    <damo@bunsenlabs.org>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#
# Save options are for  Conky(s)
#                       Tint2(s)
#                       Openbox theme
#                       GTK theme
#                       Background (uses Nitrogen or feh, depending which
#                                   has the newer saved bg config file)
#                       Alt Menu (dmenu)
#                       Lightdm login gtk greeter (currently disabled)
#                       Exit dialog theme
#                       X configs (.bashrc, .Xresources)
#                       Terminator config
#
# Paths are assumed to be BunsenLabs defaults
#
# A Screenshot is saved (Windows are hidden briefly so the image
#                        is the bare desktop, with any Tint2s
#                        or Conkys which are running, and a representive
#                        menu and window open)
#
# A time-stamped backup of rc.xml is saved "just in case".
#
# USER VARIABLE: xdotool is used to move the mouse pointer, and assumes the
# root-menu is shown with "Super + Space" keys, and the right mouse button is
# set for "r-click". If you have set these to something else, then edit the
# "MENUMODIFIER" and "MOUSECMD" variables.
# Set the variable "KEYDOWN" to where "Preferences" is in the root-menu (or
# anything else you might want displayed).
# The image viewer is set to be "bl-image-viewer". Edit the "IMGCMD" variable
# to change this.
#
# WARNING: It is assumed that the conkys are not being run via a script, so
# they will appear on all desktops. If you usually use a script, then you
# may have to make your own arrangements! Conkys in non-default directories
# can be saved, but will not be seen when running the bl conky chooser
#
########################################################################
#
# KNOWN ISSUES:
# Virtualbox does not allow the guest to move the host mouse cursor, using xdotool,
# so the screenshot may produce an incorrect theme displayed and/or poor positioning.
# A workaround is to move the cursor to some free space, and use the "Enter" key in the
# "Configurations to be saved:" dialog.
#

HELP="bl-obthemes is a script to save or restore openbox gui configurations

Usage:  $0 [-h|--help]
Options:
        -h, --help   show this message

No other CLI options are supported.

Save options:
            Conky(s)

            Tint2(s)

            Openbox theme

            GTK theme

            Background
            (uses Nitrogen or feh, depending which has the newer saved bg config file)

            Alt Menu (dmenu)

            Lightdm login gtk greeter (currently disabled)

            X configs (.bashrc, .Xresources)

            Terminal emulator config (if available)

Paths are assumed to be BunsenLabs defaults.

A Screenshot is saved
                    (Windows are hidden briefly so the image
                    is the bare desktop, with any Tint2s
                    or Conkys which are running, and a representive
                    menu and window open.)

A time-stamped backup of rc.xml is saved \"just in case\".

Configuration:

 USER VARIABLE: xdotool is used to move the mouse pointer, and assumes the
 root-menu is shown with \"Super + Space\" keys, and the right mouse button is
 set for \"r-click\". If you have set these to something else, then edit the
 \"MENUMODIFIER\" and \"MOUSECMD\" variables.
 Set the variable \"KEYDOWN\" to where \"Preferences\" is in the root-menu (or
 anything else you might want displayed).
 The image viewer is set to be \"bl-image-viewer\". Edit the \"IMGCMD\" variable
 to change this.

WARNING:
 It is assumed that the conkys are not being run via a script, so
 they will appear on all desktops. If you usually use a script, then you
 may have to make your own arrangements! Conkys in non-default directories
 can be saved, but will not be seen when running the bl conky chooser.

KNOWN ISSUES:
 Virtualbox does not allow the guest to move the host mouse cursor, using xdotool,
 so the screenshot may produce an incorrect theme displayed and/or poor positioning.
 A workaround is to move the cursor to some free space, and use the \"Enter\" key in the
 \"Configurations to be saved:\" dialog.
"
# look for a help option somewhere
for i in "$@"
do
    case "$i" in
    -h|--help)
        echo "$HELP"
        exit 0
        ;;
    esac
done

#### VARIABLES #########################################################

### USER SETTINGS
IMGCMD="bl-image-viewer"    # application command to view screenshot
MENUMODIFIER="super+space"  # keybind for show root-menu
MOUSECMD="click 3"          # mouse r-click
KEYDOWN=11           # adjust this for where "Preferences" is in the menu

### GLOBALS
USRCONFIGPATH="$HOME/.config/blob"
SYSCONFIGPATH="/usr/share/bunsen/utilities/blob"
CURSESSFILE="$USRCONFIGPATH/current"

### CONFIGS VARIABLES
OBPATH="$HOME/.config/openbox"
RCFILE="$OBPATH/bl-rc.xml" # NB now using the new BunsenLabs file name
OLDRCFILE="$OBPATH/rc.xml"
GTK2=".gtkrc-2.0"
GTK2MINE=".gtkrc-2.0.mine"
GTK3="$HOME/.config/gtk-3.0"
GTK3x="$HOME/.config/xfce4/xfconf/xfce-perchannel-xml/xfce4-notifyd.xml"
FEHFILE="$HOME/.fehbg"
NITRODIR="$HOME/.config/nitrogen"
NITROFILE="$NITRODIR/bg-saved.cfg"
CONKYPATH="$HOME/.config/conky"
CONKYSESSION="$CONKYPATH/conky-sessionfile"
TINTSESSION="$HOME/.config/tint2/tint2-sessionfile"
DMENUDIR="$HOME/.config/dmenu"
DMENU="dmenu-bind.sh"
LDMDIR="/etc/lightdm"
LDM="lightdm-gtk-greeter.conf"
#EXITDIR="$HOME/.config/bl-exit"
#SYSEXITDIR="/etc/bl-exit"
#EXITFILE="$EXITDIR/bl-exitrc"
XFILE=".Xresources"
BASHFILE=".bashrc"
#TERMDIR="$HOME/.config/terminator"
#TERMFILE='' # now termfile is local in saveSettings()

### END CONFIGS VARIABLES

# packages needed for particular GTK themes
declare -A theme_pkgs=(
[Beam]=bunsen-themes
[Beam-HiDPI]=bunsen-themes
[BL-Fever_Room]=bunsen-themes
[BL-Lithium]=bunsen-themes
[BL-Lithium-light]=bunsen-themes
[Bunsen-He-flatish]=bunsen-themes
)

# packages needed for particular icon themes
declare -A icon_pkgs=(
[Faenza-Dark-Bunsen]='bunsen-faenza-icon-theme'
[Faenza-Bunsen]='bunsen-faenza-icon-theme'
[Paper-Bunsen]='bunsen-paper-icon-theme'
[Papirus-Bunsen-grey]='bunsen-papirus-icon-theme'
[Papirus-Bunsen-bluegrey]='bunsen-papirus-icon-theme'
[Papirus-Bunsen-Dark-grey]='bunsen-papirus-icon-theme'
[Papirus-Bunsen-Dark-bluegrey]='bunsen-papirus-icon-theme'
)

THEMEPATH_1="$HOME/.themes"
THEMEPATH_2="$HOME/.local/share/themes"
THEMEPATH_3="/usr/share/themes"
THEMEPATH_4="/usr/local/share/themes"
gtkPaths=("$THEMEPATH_1" "$THEMEPATH_2" "$THEMEPATH_3" "$THEMEPATH_4")

ICONPATH_1="$HOME/.icons"
ICONPATH_2="$HOME/.local/share/icons"
ICONPATH_3="/usr/share/icons"
ICONPATH_4="/usr/local/share/icons"
iconPaths=("$ICONPATH_1" "$ICONPATH_2" "$ICONPATH_3" "$ICONPATH_4")


### DIALOG VARIABLES
DIALOG="yad --center --undecorated --borders=20 --window-icon=distributor-logo-bunsenlabs --fixed"
DIALOGDEC="yad --center  --borders=20 --window-icon=distributor-logo-bunsenlabs"
TITLE="BLOB Configuration Manager"
T="--text="
OK="--button=OK:0"
CANCEL="--button=gtk-cancel:1"
EXIT="--button=gtk-quit:1"
CLOSE="--button=gtk-close:1"
TXTINTRO='<big><b>BunsenLabs
Openbox Configuration Manager</b></big>


<b>Save or Restore settings for:</b>

    Openbox theme
    GTK theme
    Conkys
    Tint2
    Desktop Background
    Alt Menu (dmenu)
    LightDM theme (currently disabled)
    X configs (.bashrc, .Xresources)
    Terminal (if config file exists)
    + Screenshot'

PICKOB="OB theme"
PICKGTK="GTK theme"
PICKBG="Background Wallpaper"
PICKCONKY="Conky"
PICKTINT="Tint2"
PICKDMENU="dmenu (Alt menu)"
PICKLDM="Lightdm Login theme"
#PICKEXIT="Exit dialog theme"
#PICKTERM='' # now not global, pickterm local in saveSettings()
PICKX="X configs"

### END DIALOG VARIABLES

#### END VARIABLES #####################################################


### FUNCTIONS ##########################################################

function upgradeBlobs(){
    for i in "$USRCONFIGPATH"/*; do
        [[ -d $i ]] || continue
        mkdir -p "$i/user"
        moveFile(){ # $1 is file, $2 is target dir
            [[ -f "$2/${1##*/}" ]] && return 0
            [[ -f "$1" ]] || {
                echo "$0: Upgrading ${i}: WARNING Cannot move file ${1}, it does not exist" >&2
                return 1
            }
            mkdir -p "$2"
            mv "$1" "$2" || exit
        }
        moveDir(){
            [[ -d "$2/${1##*/}" ]] && return 0
            [[ -d "$1" ]] || {
                echo "$0: Upgrading ${i}: WARNING Cannot move directory ${1}, it does not exist" >&2
                return 1
            }
            mkdir -p "$2"
            mv "$1" "$2" || exit
        }
        touch "$i/newsettings"
        while read -r TAG VAL; do
            home_marker='%USERHOME%'
            case "$TAG" in
                "[TINT2]"       )   printf '%s %s\n' "$TAG" "$VAL" >> "$i/newsettings"
                                    ;;
                "[CONKY]"       )   printf '%s %s\n' "$TAG" "$VAL" >> "$i/newsettings"
                                    ;;
                "[ICONS]"       )   printf '%s %s\n' "$TAG" "$VAL" >> "$i/newsettings"
                                    ;;
                "[GTK]"         )   moveFile "$i/.gtkrc-2.0" "$i/user"
                                    moveFile "$i/.gtkrc-2.0.mine" "$i/user"
                                    moveFile "$i/xfce4-notifyd.xml" "$i/user/.config/xfce4/xfconf/xfce-perchannel-xml"
                                    moveDir "$i/gtk-3.0" "$i/user/.config"
                                    printf '%s %s\n' "$TAG" "$VAL" >> "$i/newsettings"
                                    ;;
                "[OBTHEME]"     )   printf '%s %s\n' "$TAG" "$VAL" >> "$i/newsettings"
                                    ;;
                "[BACKGROUND]"  )   if [[ $VAL = FEH ]];then
                                        moveFile "$i/.fehbg" "$i/user"
                                    else
                                        moveFile "$i/bg-saved.cfg" "$i/user/.config/nitrogen"
                                    fi
                                    printf '%s %s\n' "$TAG" "$VAL" >> "$i/newsettings"
                                    ;;
                "[DMENU]"       )   moveFile "$i/dmenu-bind.sh" "$i/user/.config/dmenu"
                                    printf '%s %s\n' "$TAG" "$VAL" >> "$i/newsettings"
                                    ;;
                "[LIGHTDM]"     )   printf '%s %s\n' "$TAG" "$VAL" >> "$i/newsettings"
                                    ;;
                "[EXITRC]"      )   printf '%s %s\n' "$TAG" "$VAL" >> "$i/newsettings"
                                    ;;
                "[XFILES]"      )   moveFile "$i/.Xresources" "$i/user"
                                    moveFile "$i/.bashrc" "$i/user"
                                    printf '%s %s\n' "$TAG" "$VAL" >> "$i/newsettings"
                                    ;;
                "[TERMINATOR]"  )   moveFile "$i/config" "$i/user/.config/terminator"
                                    printf '%s %s\n' '[Terminator]' '.config/terminator/config' >> "$i/newsettings"
                                    ;;
                '['*']'         )   printf '%s %s\n' "$TAG" "$VAL" >> "$i/newsettings"
                                    ;;
                *               )   echo -e "Upgrading ${i}: ${TAG}:  Unknown value!" >&2
                                    continue
                                    ;;
            esac
        done < "$i/settings.cfg"
        mv -f "$i/newsettings" "$i/settings.cfg"
    done
}

# Kill only with exact match, and only if process belongs to executor.
# Usage: safeKill <processname>
function safeKill() {
    pkill -x -u "$USER" "$1"
}

# sets globals NUMDIRS and CURRENTSESSION
function getCurrent(){      # get name of currently set BLOB config
    local dirs
    NUMDIRS=0
    shopt -s nullglob
    dirs=( "$USRCONFIGPATH"/*/ "$SYSCONFIGPATH"/*/ )
    NUMDIRS=${#dirs[@]}
    shopt -u nullglob
    if (( NUMDIRS == 0 ));then
        if [[ -f $CURSESSFILE ]];then
            rm "$CURSESSFILE"
        fi
    elif (( NUMDIRS > 0 )) && [[ -f $CURSESSFILE ]];then
        CURRENTSESSION=$(< "$CURSESSFILE")
    fi
}

function Intro(){
    local RET
    getCurrent
    #  if blob/ is empty, then don't display "View Saved" option in Intro dialog
    if (( NUMDIRS > 0 ));then
        $DIALOGDEC "$T$TXTINTRO" \
        --title="$TITLE" \
        --button="Save Settings:0" --button="View Saved:2" $CLOSE \
        --borders=30 \
        2>/dev/null
    else
        $DIALOGDEC \
        --title="$TITLE" \
        "$T$TXTINTRO" \
        --button="Save Settings:0" $CLOSE \
        --borders=30 \
        2>/dev/null
    fi
    RET=$?
    case $RET in
        0)  setName
            saveSettings
            getScrot
            if [[ -d $CONFIGDIR_BKP ]];then
                rm -rf "$CONFIGDIR_BKP"
                echo -e "\n  Temporary $CONFIGDIR deleted\n"
            fi
            restoreSettings
            ;;
        1)  echo "CANCELLED..."
            exit 0
            ;;
        2)  getCurrent
            restoreSettings
            ;;
        *)  echo "RETURN ERROR" >&2
            ;;
    esac
}

####################### save functions #################################

# sets globals CONFIGDIR SETTINGS LISTMSG NEWNAME for storing new theme
function setName(){  # set name of collection, make dir and session settings file
    MSG="  Configurations will be saved to a new directory in  \
    \n  $USRCONFIGPATH\n\n  Enter name of new collection...  "
    MSG2="  No file specified for new saved session.\n\n  Try again?"
    DEL=0
    while true;do  # loop dialog if nothing is selected
        NEWNAME=$($DIALOG --entry \
            $CANCEL --button="OK:0" \
            "$T$MSG" \
            2>/dev/null )
        if (( $? == 1 )) ;then # Cancel was selected
            Intro
        elif [[ ! $NEWNAME ]] ;then     # entry was empty
            $DIALOG --image="dialog-question" \
            "$CANCEL" "$OK" \
            "$T$MSG2" \
            2>/dev/null
            RET=$?
            echo -e "\n  No name entered for new collection!" >&2
            if (( RET == 0 ));then
                continue
            else
                Intro
            fi
        else
            NEWNAME=${NEWNAME// /_}    # replace any spaces in dir name
            CONFIGDIR="$USRCONFIGPATH/$NEWNAME"
            CONFIGDIR_BKP="${CONFIGDIR}.bkp"
            if [[ -d $CONFIGDIR ]];then
                echo -e "\n  $CONFIGDIR already exists"

                $DIALOG --form --image="dialog-question" \
                --text="Overwrite existing saved session?" \
                "$CANCEL" "$OK" \
                --width=300 \
                2>/dev/null

                if (( $? == 0 ));then
                    mv "$CONFIGDIR" "$CONFIGDIR_BKP" # && mkdir -p "$CONFIGDIR"
                    DEL=1
                else
                    continue
                fi
            fi
            mkdir -p "$CONFIGDIR"
            SETTINGS="$CONFIGDIR/settings.cfg"
            LISTMSG="$CONFIGDIR/LISTMSG.txt"
            :> "$SETTINGS"
            :> "$LISTMSG"
            break
        fi
    done
    TIME=$(date)
    if (( DEL == 1 ));then
        TXT="  (Existing session overwritten)"
    else
        TXT=""
    fi
    echo -e "\n  Configuration will be saved as: $NEWNAME$TXT"

#     store list in listfile
    echo -e "<b>Configuration name: $NEWNAME</b>\t$TXT\nSaved at $TIME\n" >> "$LISTMSG"
}

function getBg(){    # find if feh or nitrogen was used. Save config file(s)
    if [[ -e $NITROFILE ]] && [[ -e $FEHFILE ]];then  # see which was last used to set background
        if [[ $NITROFILE -nt $FEHFILE ]];then # use most recent method
            BGSET="NITROGEN"
        else
            BGSET="FEH"
        fi
    elif [[ -e $FEHFILE ]];then  # use feh for background
        BGSET="FEH"
    elif [[ -e $NITROFILE ]];then    # use nitrogen for background
        BGSET="NITROGEN"
    else
        echo -e "\n  No background-setting application found" >&2
        BGSET="None"
    fi
    echo -e "\n  Background to be set with $BGSET"
    case "$BGSET" in
        FEH     )   echo "[BACKGROUND] $BGSET" >> "$SETTINGS"
                    cp "$FEHFILE" "$CONFIGDIR"
                    echo -e "\n  $FEHFILE copied"
                    getFeh
                    ;;
        NITROGEN)   echo "[BACKGROUND] $BGSET" >> "$SETTINGS"
                    cp "$NITROFILE" "$CONFIGDIR"
                    echo -e "\n  Saved Nitrogen file: $NITROFILE"
                    getNitrogen
                    ;;
        None    )   echo -e "\n  No background-setting application found" >&2
                    echo "[BACKGROUND] $BGSET" >> "$SETTINGS"
                    ;;
        *       )   echo -e "\n  ERROR: No background config found" >&2
                    exit 1
                    ;;
    esac
}

function getFeh(){    # get Feh saved backgrounds
    local FFILE="$CONFIGDIR/.fehbg"
    if [[ -f $FFILE ]];then
        local BG=""
        # get fields between single quotes
        while read -r line;do
            BG="$BG$line;\n\t"
        done < <(grep -o "'[^']*'" "$FFILE" | sed "s/'//g" 2>/dev/null)
        echo -e "\n  Backgrounds set with Feh, using:\t$FEHFILE"
        echo -e "\t$BG"
        echo -e "Background set with feh:\n\t$BG" >> "$LISTMSG"
    else
        echo -e "\n  $FFILE not found" >&2
    fi
}

function getNitrogen(){  # get Nitrogen saved backgrounds
    local NFILE="$CONFIGDIR/bg-saved.cfg"
    if [[ -f $NFILE ]];then
        local BG=""
        while read -r line;do
            [[ $line = 'file='* ]] || continue
            BG="$BG${line#file=};\n\t"
        done < "$NFILE"
        echo -e "\n  Backgrounds set with Nitrogen, using:\t$NITROFILE"
        echo -e "\t$BG"
        echo -e "Background set with nitrogen:\n\t$BG" >> "$LISTMSG"
    else
        echo -e "\n  $NFILE not found" >&2
    fi
}

# generates command array idCmd from window id (hex or decimal)
# WARNING WM_COMMAND is deprecated: https://www.x.org/releases/X11R7.6/doc/xorg-docs/specs/ICCCM/icccm.html#obsolete_session_manager_conventions
# Usage: getIdCmd <id>
getIdCmd() {
    local wmc del s
    wmc=$(xprop -id "$1"  WM_COMMAND)
    wmc=${wmc#*\"} # strip first & last quotes & everything outside
    wmc=${wmc%\"*}
    wmc=${wmc//\\\"/\"} # unescape any inner quotes
    del='", "'
    s=${wmc}${del}
    idCmd=()
    while [[ -n $s ]]
    do
        idCmd+=("${s%%${del}*}")
        s=${s#*${del}}
    done
}

function getConky(){
    local CONKYCMD=""
    LISTMSGTXT="Running Conkys:"
    CMDTXT="[CONKY] "
    CONKYTXT=""
    NUM_DESKTOPS=$(xdotool get_num_desktops)

    local -A arrSTICKY
    if [[ $(pidof conky) ]];then
        while read -r id;do  # get all running conky id's
            arrSTICKY["$id"]=1
        done < <(xdotool search --class conky)

        for (( i=0; i<NUM_DESKTOPS; i++ ));do  # get all conkys running on specific desktops
            while read -r id;do
                unset arrSTICKY["$id"] # remove from sticky list
                if ! [[ -z "$id" ]];then
                    getIdCmd "$id" # generates array idCmd
                    CONKYCMD=${idCmd[*]} # NB now in string, filepaths with spaces will be broken.
                    if [[ "$CONKYCMD" == "conky" ]] || [[ "$CONKYCMD" == "conky -q" ]];then
                        CONKYTXT="$CONKYTXT\n\tDesktop $i:  Default Conky"
                    else
                        CONKYTXT="$CONKYTXT\n\tDesktop $i:  $CONKYCMD"
                    fi
                    # command to start on specified desktop with wmctrl
                    CONKYCMD="sleep 1 && wmctrl -s $i && $CONKYCMD &;"
                    CMDTXT="$CMDTXT$CONKYCMD"
                fi
            done < <(xdotool search --desktop $i --class conky)
        done

        for id in "${!arrSTICKY[@]}";do  # get commands - we don't need wmctrl for these
            if ! [[ -z "$id" ]];then
                getIdCmd "$id" # generates array idCmd
                CONKYCMD=${idCmd[*]} # NB now in string, filepaths with spaces will be broken.
                if [[ "$CONKYCMD" == "conky" ]] || [[ "$CONKYCMD" == "conky -q" ]];then
                    CONKYTXT="$CONKYTXT\n\tDefault Conky"
                else
                    CONKYTXT="$CONKYTXT\n\t$CONKYCMD"
                fi
                CONKYCMD="sleep 1 && $CONKYCMD &;"
                CMDTXT="$CMDTXT$CONKYCMD"
            fi
        done
        echo "$CMDTXT" >> "$SETTINGS"
        echo -e "$LISTMSGTXT\t$CONKYTXT\n" >> "$LISTMSG"
        echo -e "\n  Saved running Conky(s)"
    else
        DLG=$($DIALOG --form --image="dialog-warning" \
        --text="You selected to save Conkys\nbut none are running" \
        "$OK" \
        --width=300) 2>/dev/null
    fi
    }

function getTint(){
    declare -a arrTINT
    if [[ $(pidof tint2) ]];then
        while read -r pid cmd;do
            if [[ ${cmd%% *} == tint2 ]];then
                TPATH=$(echo "$cmd" | awk '{print $NF";"}')
                arrTINT+=("$TPATH")
            fi
        done < <(pgrep -a -u "$USER" tint2)

        TXT="Tint2s:\n\n"
        MSG="Running Tint2s:"
        TINTCMD=""
        LISTMSGTXT=""

        for i in "${arrTINT[@]}";do
            TXT="$TXT$i"
            TINT=${i//;}
            if [[ "$TINT" == "tint2" ]];then
                TINTCMD="$TINTCMD$TINT;"
                LISTMSGTXT="$LISTMSGTXT\n\tDefault Tint2"
            else
                TINTCMD="$TINTCMD$TINT;"
                LISTMSGTXT="$LISTMSGTXT\n\t$TINT"
            fi
        done

        echo "[TINT2] $TINTCMD" >> "$SETTINGS"
        echo -e "$MSG\t$LISTMSGTXT\n" >> "$LISTMSG"
        echo -e "\n  Saved running Tint2(s)"
    else
        DLG=$($DIALOG --form --image="dialog-warning" \
        --text="You selected to save Tint2\nbut none are running" \
        "$OK" \
        --width=300) 2>/dev/null
    fi
}

function getOBtheme(){   # copy <theme> section from rc.xml to obtheme.txt
    [[ -r $RCFILE ]] || RCFILE="$OLDRCFILE"
    tag="theme"
    sed -n "/<$tag>/,/<\/$tag>/p" "$RCFILE" > "$CONFIGDIR/obtheme.txt"
    getOBname
    echo "[OBTHEME] $OBTHEME" >> "$SETTINGS"
}

function getOBname(){    # get Openbox theme name
    OBFILE="$CONFIGDIR/obtheme.txt"
    # OBTHEME=$(awk 'NR==2 {print;exit}' "$OBFILE" | awk -F'[>|<]' '{print $3}')
    # sed command is long, but it's more precise, and a little bit faster than two awk calls
    OBTHEME=$(sed -nr '/<theme>/ {N;s/^[[:blank:]]*<theme>[[:space:]]*<name>([^<]*)<\/name>.*$/\1/p;q}' "$OBFILE")
    TXT="Openbox theme:  $OBTHEME\n"
    echo -e "\n  Saved $TXT"
    echo "$TXT" >> "$LISTMSG"
}

function getGTKtheme(){
    GTKTHEMES=( "$HOME/$GTK2" "$HOME/$GTK2MINE" "$GTK3" "$GTK3x" )
    for f in "${GTKTHEMES[@]}";do
        if [[ -f $f ]];then
            cp "$f" "$CONFIGDIR"
        elif [[ -d $f ]];then
            GTKDIR="$CONFIGDIR/$(basename "$f")"
            mkdir -p "$GTKDIR"
            cp "$f/settings.ini" "$GTKDIR"
            cp "$f/gtk.css" "$GTKDIR"
        fi
    done
    getGTKname
}

function getGTKname(){   # get GTK theme name and Icons name
    GTKFILE="$CONFIGDIR/.gtkrc-2.0"
    while read -r line;do
        if [[ $line = *"gtk-theme-name"* ]];then
            GTKTHEME=$(awk -F '"' '{print $2}' <<< "$line")
            echo "[GTK] $GTKTHEME" >> "$SETTINGS"
        fi
        if [[ $line = *"gtk-icon-theme-name"* ]];then
            ICONS=$(awk -F '"' '{print $2}' <<< "$line")
            echo "[ICONS] $ICONS" >> "$SETTINGS"
        fi
    done < "$GTKFILE"
    TXT="GTK theme:  $GTKTHEME;  Icon Theme: $ICONS\n"
    echo -e "\n  Saved $TXT"
    echo  "$TXT" >> "$LISTMSG"
}

function getDmenu(){
    if [[ -d $DMENUDIR ]];then
        cp "$DMENUDIR/$DMENU" "$CONFIGDIR"
        echo "[DMENU]" >> "$SETTINGS"
        TXT="dmenu config:  $DMENUDIR/$DMENU\n"
        echo -e "\n  Saved $TXT"
        echo "$TXT" >> "$LISTMSG"
    else
        echo "  $DMENUDIR/$DMENU not found"
    fi
}

function getLightdm(){
    if [[ -f $LDMDIR/$LDM ]];then
        cp "$LDMDIR/$LDM" "$CONFIGDIR"
        TXT="Lightdm config:  $LDMDIR/$LDM\n"
        echo -e "\n  Saved $TXT"
        echo "[LIGHTDM]" >> "$SETTINGS"
        echo "$TXT" >> "$LISTMSG"
    fi
}

# passed termfile as $1 and pickterm as $2 by saveSettings()
function getTerminal(){
    local termfile target_dir
    termfile="$1"
    termname="$2"
    if [[ -e $HOME/$termfile ]];then
        target_dir="$CONFIGDIR/user/${termfile%/*}"
        mkdir -p "$target_dir"
        cp "$HOME/$termfile" "$target_dir"
        TXT="$termname config:  ~/$termfile\n"
        echo -e "\n  Saved $TXT"
        echo "[$termname] $termfile" >> "$SETTINGS"
        echo "$TXT" >> "$LISTMSG"
    fi
}

function getXconfig(){
    XFILE="$HOME/.Xresources"
    BASHFILE="$HOME/.bashrc"
    if [[ -f $XFILE ]];then
        cp "$XFILE" "$CONFIGDIR"
    fi
    if [[ -f $BASHFILE ]];then
        cp "$BASHFILE" "$CONFIGDIR"
    fi
    TXT="X config:  ~/.Xresources; ~/.bashrc; (~/.bashrc will not be auto-restored)\n"
    echo -e "\n  Saved $TXT"
    echo "[XFILES]" >> "$SETTINGS"
    echo "$TXT" >> "$LISTMSG"
}

function checkTint2(){   # kill or restart tint2s for screenshot, if necessary
    if [[ $1 = stop ]];then
        if ! grep -q "TINT2" "$SETTINGS" ;then
            tmpTINT=$(mktemp --tmpdir blob.XXXX) # make blank tempfile, to save running tint2 paths
            if [[ $(pidof tint2) ]];then
                pgrep -a -u "$USER" tint2 | while read -r pid cmd;do
                    if [[ ${cmd%% *} = tint2 ]];then
                        echo "$cmd" >> "$tmpTINT"
                    fi
                done
            safeKill tint2
            fi
        fi
    fi
    if [[ $1 = start ]];then
        if [[ -f "$tmpTINT" ]] 2>/dev/null;then
            while read -r line;do
                ($line &) &>/dev/null
                sleep 1s
            done < "$tmpTINT"
            rm -f "$tmpTINT"
        fi
    fi
}

function getWINDOWS(){  # Minimize/Activate windows for scrot. Args= 'min', 'raise', 'all'
    declare -a arrWINDOWS

    xdoFN() { echo "$0: xdoFN() not set" >&2; exit 1; }
    if [[ "$1" == "min" ]];then
        xdoFN() { xdotool windowminimize "$1";}
    elif [[ "$1" == "raise" ]] || [[ "$1" == "all" ]];then
        xdoFN() { xdotool windowactivate --sync "$1";}
    fi

    # get window id's on current desktop, which aren't sticky; convert hexcode to int.
    # add window ids to array, if not conky
    dtop=$(xdotool get_desktop)
    while read -r id dt _
    do
        [[ $dt = "$dtop" ]] || continue
        arrWINDOWS+=($(( id )))
    done < <(wmctrl -l)

    # minimize/activate non-conky windows
    conk="$(xdotool search --desktop "$dtop" --class 'Conky')"
    for win in "${arrWINDOWS[@]}";do
        if ! [[ $win = "$conk" ]];then
            ( xdoFN "$win" ) 2>/dev/null
        fi
    done
    if [[ "$1" == "all" ]];then # activate any hidden conkys
        for CONK in $(xdotool search --class 'Conky');do
            xdotool windowactivate "$CONK" 2>/dev/null
        done
    fi
}

function getScrot(){
    local conkyFLAG currDESKTOP SCROT
    conkyFLAG=1
    currDESKTOP=$(xprop -root _NET_CURRENT_DESKTOP | tail -c -2)
    SCROT="$USRCONFIGPATH/$NEWNAME/${NEWNAME}.jpg"
    MONS=$(xrandr -q | grep -c " connected")    # number of monitors
    # set mouse position, for appearance of root-menu
    screenW=$(xrandr -q | awk '/Screen/ {print $8}')
    screenH=$(xrandr -q | awk '/Screen/ {print $10}')
    screenH=${screenH%,}

    if (( MONS == 1 ));then # single monitor
        appX=$(( (screenW/20)*8 ))
        menuX=$(( (screenW/20)*2 ))
    else
        appX=$(( (screenW/20)*4 ))
        menuX=$(( (screenW/20)*1 ))
    fi
    appY=$(( (screenH/20)*4 ))
    menuY=$(( (screenH/20)*4 ))

    if ! grep "CONKY" "$SETTINGS" &>/dev/null;then    # Conkys not to be saved
        wmctrl -k on    # hide windows, show desktop
        conkyFLAG=0
    else                # Conkys will be saved, so don't hide them for the scrot
        getWINDOWS min  # minimize windows
    fi
    checkTint2 stop     # stop running Tint2s for the scrot, if not selected to be saved
    # start lxappearance
    lxappearance 2>/dev/null &
    sleep 0.5
    # get lx window, make sure it loses focus, then move mouse and start root-menu
    LX=$(xdotool getwindowfocus)
    xdotool windowmove --sync "$LX" "$appX" "$appY" && sleep 0.1 && \
    xdotool mousemove --sync --window "$LX" -- -50 0 && xdotool click 1
    xdotool mousemove --sync "$menuX" "$menuY" && xdotool key --clearmodifiers "$MENUMODIFIER"

    i=1
    while (( i <= KEYDOWN ));do
        xdotool key --delay 50 Down
        i=$(( i+1 ))
    done
    xdotool key --delay 20 Right && sleep 0.3

    # take scrot
    scrot -t 9 "$SCROT"    # scrot thumbnail @9% fullsize

    # close root menu
    xdotool mousemove_relative --sync --polar 0 10 $MOUSECMD
    # kill lxappearance
    pkill -P "$$" lxappearance

    # restore hidden windows
    if (( conkyFLAG == 0 ));then
        getWINDOWS all              # including hidden conkys
    else
        getWINDOWS raise            # Conkys weren't closed for scrot
    fi
    wmctrl -s "$currDESKTOP" # return to desktop that BLOB was started on, if conkys used 'wmctrl -s'
    checkTint2 start                # restore any stopped Tint2s
}

# sets termfile and pickterm inside saveSettings()
function checkTerm(){
    case $( readlink /etc/alternatives/x-terminal-emulator ) in
    /usr/bin/lxterminal)
        termfile='.config/lxterminal/lxterminal.conf'
        pickterm='Lxterminal'
        ;;
    /usr/bin/terminator)
        termfile='.config/terminator/config'
        pickterm='Terminator'
        ;;
    /usr/bin/xfce4-terminal.wrapper)
        termfile='.config/xfce4/terminal/terminalrc'
        pickterm='Xfce4-terminal'
        ;;
    /usr/bin/sakura)
        termfile='.config/sakura/sakura.conf'
        pickterm='Sakura'
        ;;
    *)
        termfile=''
        ;;
    esac
}

function saveSettings(){
    local columns select termfile pickterm
    select="FALSE"
    while true;do
        columns=(
            "$select" "$PICKOB"
            "$select" "$PICKGTK"
            "$select" "$PICKBG"
            "$select" "$PICKCONKY"
            "$select" "$PICKTINT"
            "$select" "$PICKDMENU"
            #"$select" "$PICKLDM"
            #"$select" "$PICKEXIT"
            "$select" "$PICKX"
        )
        checkTerm # sets termfile and pickterm
        # add terminal to array if one with a config file is in use
        if  [[ -n $termfile ]];then
            columns+=("$select" "$pickterm")
        fi
        CHOICE=$($DIALOGDEC --list --checklist \
            --title="Choose the configs to save..." \
            --button="Select All:2" \
            $CANCEL $OK \
            --height=340 \
            --column="Select" --column="Config" "${columns[@]}" \
            2>/dev/null )
            ret=$?
        if (( ret == 1 )); then # cancel button pressed
            cleanup all
            restoreSettings
        elif (( ret == 2 ));then
            select="TRUE"
            continue
        else
            if [[ ! $CHOICE ]] ; then # entry field is empty, so try again
                RET=$($DIALOG  --image="dialog-question" \
                --text="\n  Make a selection...." \
                $EXIT $OK \
                --width=300 \
                2>/dev/null )
                if (( $? == 1 ));then
                    cleanup all
                    exit 0
                else
                    select='FALSE'
                    continue
                fi
            else
                i=0
                retChoice=()
                OIFS=$IFS # save Internal Field Separator
                IFS='|' # separator is "|" in returned choices
                # dialog return is in format 'TRUE|value|\nTRUE|value'
                for ret in $CHOICE; do
                    if [[ $ret = *TRUE* ]];then
                        continue
                    fi
                    retChoice[$i]="$ret"
                    i=$((i+1))
                done
                IFS=$OIFS # reset IFS back to default
                for item in "${retChoice[@]}";do
                    case "$item" in
                        "$PICKOB"   )   getOBtheme
                                        ;;
                        "$PICKGTK"  )   getGTKtheme
                                        ;;
                        "$PICKBG"   )   getBg
                                        ;;
                        "$PICKCONKY")   getConky
                                        ;;
                        "$PICKTINT" )   getTint
                                        ;;
                        "$PICKDMENU")   getDmenu
                                        ;;
                        "$PICKLDM"  )   getLightdm
                                        ;;
                        "$PICKEXIT" )   getBLexitrc
                                        ;;
                        "$pickterm" )   getTerminal "$termfile" "$pickterm"
                                        ;;
                        "$PICKX"    )   getXconfig
                                        ;;
                        *           )   echo -e "\n  Unknown value!" >&2
                                        exit 1
                                        ;;
                    esac
                done
                break
            fi
        fi
    done
        TXT="<big><b><u>Openbox Configurations to be saved:</u></b></big>\n\n"
        TXT2=$(cat "$LISTMSG")
        $DIALOG --text="$TXT$TXT2"
        ret=$?
        if (( ret == 1 ));then
            cleanup all
            restoreSettings
        else
            echo "$NEWNAME" > "$CURSESSFILE"     # replace entry in saved config flag file
        fi
}

###################### end save functions ##############################

###################### restore functions ###############################

function checkICONS(){ # check if icon theme is still present
    local FOUNDICONS=0
    local ICOTXT="Icon theme <b>$1</b> not found\n\n  The default icon theme will be used..."
    for i in "${iconPaths[@]}";do # iconPaths defined at top
        if [[ -d "$i/$1" ]];then
            echo -e "\n  Found $1 icon theme"
            FOUNDICONS=1
            break
        fi
    done
    if (( FOUNDICONS == 0 ));then
        local pkg="${icon_pkgs[$1]}"
        if [[ -n "${pkg}" ]] && hash bl-install >/dev/null
        then
            echo -e "\n  Icon theme  $1  was not found\n  Offering to install $pkg..."
            local INSTICOTXT="Needed icon theme <b>$1</b> not found\n Would you like to install the package <b>${pkg}</b> which contains that theme?"
            $DIALOG --image="dialog-question" "$T$INSTICOTXT" "CANCEL" "OK" 2>/dev/null
            if (( $? == 0 ))
            then
                local retfile retval
                retfile="$( mktemp )"
                bl-install -f "$retfile" "$pkg"
                wait $!
                retval="$(<"$retfile")"
                rm "$retfile"
                if [[ "$retval" = 0 ]]
                then
                    return 0
                else
                    $DIALOG --image="dialog-warning" "${T}Install failed." "$CLOSE" 2>/dev/null
                fi
            fi
        fi
        echo -e "\n  Icon theme  $1  was not found\n  The default Icon theme will be used..."
        $DIALOG --image="dialog-warning" "$T$ICOTXT" "$CLOSE" 2>/dev/null
    fi
}

function checkGTK(){    # check if gtk theme is still present
    local FOUNDGTK=0
    local GTKTXT="GTK theme <b>$1</b> not found\n\n  The default GTK theme will be used..."
    for i in "${gtkPaths[@]}";do # gtkPaths defined at top
        if [[ -d "$i/$1" ]];then
            echo -e "\n  Found $1 GTK theme"
            FOUNDGTK=1
            break
        fi
    done
    if (( FOUNDGTK == 0 ));then
        local pkg="${theme_pkgs[$1]}"
        if [[ -n "${pkg}" ]] && hash bl-install >/dev/null
        then
            echo -e "\n  GTK theme  $1  was not found\n  Offering to install $pkg..."
            local INSTGTKTXT="Needed GTK theme <b>$1</b> not found\n Would you like to install the package <b>${pkg}</b> which contains that theme?"
            $DIALOG --image="dialog-question" "$T$INSTGTKTXT" "CANCEL" "OK" 2>/dev/null
            if (( $? == 0 ))
            then
                local retfile retval
                retfile="$( mktemp )"
                bl-install -f "$retfile" "$pkg"
                retval="$(<"$retfile")"
                rm "$retfile"
                if [[ "$retval" = 0 ]]
                then
                    return 0
                else
                    $DIALOG --image="dialog-warning" "${T}Install failed." "$CLOSE" 2>/dev/null
                fi
            fi
        fi
        echo -e "\n  GTK theme  $1  was not found\n  The default GTK theme will be used..."
        $DIALOG --image="dialog-warning" "$T$GTKTXT" "$CLOSE" 2>/dev/null
    fi
}

function restoreGTK(){   # arg is chosen saved config dir
    GTKPATHS=( "$HOME" "$HOME" "$GTK3" "$GTK3x" )
    GTKSAVED=( "$1/$GTK2" "$1/$GTK2MINE" "$1/gtk-3.0" "$1/xfce4-notifyd.xml" )
    i=0
    for f in "${GTKSAVED[@]}";do
        if [[ -e $f ]];then     # if destination exists
            if [[ -e ${GTKPATHS[i]} ]];then
                if [[ ${GTKSAVED[i]} = $1/gtk-3.0 ]];then
                    cp "${GTKSAVED[i]}"/* "${GTKPATHS[i]}" # restore contents of gtk-3.0
                    echo -e "\n  Restored gtk-3.0 files"
                else
                    cp "${GTKSAVED[i]}" "${GTKPATHS[i]}"
                    echo -e "\n  Restored: ${GTKSAVED[i]}"
                fi
            else
                echo -e "\n  Restore path ${GTKPATHS[i]} not found" >&2
            fi
        else
            echo -e "\n  ${GTKSAVED[i]} not found" >&2
        fi
        i=$((i+1))
    done
}

function checkOBTHEME(){
    local FOUNDOB=0
    local OBTXT="Openbox theme <b>$1</b> not found\n\n  The default Openbox theme will be used..."
    for i in "${gtkPaths[@]}";do
        if [[ -d "$i/$1/openbox-3" ]];then
            echo -e "\n  Found $1 Openbox theme"
            FOUNDOB=1
            break
        fi
    done
    if (( FOUNDOB == 0 ));then
        echo -e "\n  OB theme  $1  was not found\n  The default Openbox theme will be used..."
        $DIALOG --image="dialog-warning" "$T$OBTXT" "$CLOSE" 2>/dev/null
    fi
}

function restoreOBrc(){
    THEMEFILE="$1/obtheme.txt"
    FTEMP=$(mktemp --tmpdir blob.XXXX)
    [[ -r $RCFILE ]] || RCFILE="$OLDRCFILE"
    if grep -q '[OBTHEME]' "$1/settings.cfg" ;then
        # backup bl-rc.xml first
        RCBKP="$RCFILE.blob.$NOW"
        cp "$RCFILE" "$RCBKP"
        # remove older backups
        for f in $(find "$OBPATH" -type f|grep .blob. );do
            if [[ $f -ot $RCBKP ]];then
                rm "$f"
            fi
        done
        ## put placeholder in place of <theme> section, write to tempfile
        sed -n "/<theme>/{:a;N;/<\/theme>/!ba;N;s/.*\n/THEMESECTION\n/};p" "$RCFILE" > "$FTEMP"
        # replace placeholder from theme file
        sed -i "/THEMESECTION/{
            s/THEMESECTION//g
            r $THEMEFILE
        }" "$FTEMP"
        sed -i '/^$/d' "$FTEMP"   # remove empty lines
        cp "$FTEMP" "$RCFILE"     # overwrite rc.xml
        echo -e "\n  rc.xml backed up and edited for OB theme"
        rm -f "$FTEMP"
    fi
}

function restoreConky(){    # arg = $VAL from restoreSettings()
    local currDESKTOP CONKYCMD
    currDESKTOP=$(xprop -root _NET_CURRENT_DESKTOP | tail -c -2)   # Conkys may have been started on different desktops
    CONKYCMD="$1"
    if type bl-conkyzen &>/dev/null;then    # see if bl-conkyzen is installed
        if [[ -f $CONKYSESSION ]] &>/dev/null; then
            :> "$CONKYSESSION" # create/overwrite conky session file
            # write to conky session file...
            echo "${CONKYCMD//;/$'\n'}" >> "$CONKYSESSION"
            safeKill conky
            source "$CONKYSESSION"  # run conky commands
            wait
        fi
    else
        safeKill conky
        eval "$CONKYCMD"    # no bl-conkyzen, so just run conky commands
        wait
    fi
    echo -e "\n  Restored Conky\n"
    wmctrl -s "$currDESKTOP" && sleep 1 # return to desktop that BLOB was started on, if conkys used 'wmctrl -s'
}

function restoreTint2(){    # arg = $VAL from restoreSettings()
    TINTCMD="${1//;/$'\n'}"
    if type bl-tint2zen >/dev/null;then    # see if bl-tint2zen is installed
        if [[ -f $TINTSESSION ]] 2>/dev/null; then
            :> "$TINTSESSION"    # create/overwrite tint2 session file
            # write to tint2 session file...
            echo "$TINTCMD" >> "$TINTSESSION"
            safeKill tint2
            while read -r tintline;do
                if [[ "$tintline" == "tint2" ]];then
                    tint2 >/dev/null 2>&1 &
                    sleep 1
                    echo -e "\n  Restored Tint2: $tintline\n"
                elif [[ -n "$tintline" ]];then
                    tint2 -c "$tintline" >/dev/null 2>&1 &
                    sleep 1s
                    echo -e "\n  Restored Tint2: $tintline\n"
                fi
            done < "$TINTSESSION"
        fi
    else                    # no bl-tint2zen, so just run tint2 commands
        safeKill tint2
        for tintpath in $TINTCMD;do
            if [[ "$tintpath" == "tint2" ]] >/dev/null;then
                tint2 >/dev/null 2>&1 &     # default tint2 command
                sleep 1
                echo -e "\n  Restored Tint2: $tintpath\n"
            else
                tint2 -c "$tintpath" >/dev/null 2>&1 &
                sleep 1s
                echo -e "\n  Restored Tint2: $tintpath\n"
            fi
        done
    fi
}

function restoreDmenu(){
    DFILE="$1"
    if [[ -e $DMENUDIR ]];then        # backup DMENU first
        DMENUBKP="$DMENUDIR/$DMENU.bkp"
        cp "$DMENUDIR/$DMENU" "$DMENUBKP"
        cp "$DFILE" "$DMENUDIR"
        echo -e "\n  $DMENUDIR/$DMENU backed up and restored"
    else
        cp "$DFILE" "$DMENUDIR/$DMENU"
        echo -e "\n  $DMENUDIR/$DMENU restored"
    fi
}


## TODO: use pkexec instead of gksudo
function restoreLightdm(){   # need sudo to restore lightdm-gtk-greeter.conf
    CMD="cp $1 $LDMDIR/$LDM"
    TXT="Authenticate restore of lightdm-gtk-greeter.conf"
    while true;do
        gksudo -m "$TXT" "$CMD"
        DLG=$?
        case "$DLG" in
            0   )   MSG="Restored: lightdm-gtk-greeter.conf"
                    echo -e "\n  $MSG"
                    break
                    ;;
            255 )   MSG="  Authentication cancelled\n\nlightdm-gtk-greeter.conf was not restored"
                    echo -e "\n  $MSG" >&2
                    break
                    ;;
            *   )   MSG="  Password input failed\n\nlightdm-gtk-greeter.conf was not restored"
                    echo -e "\n  $MSG" >&2
                    $DIALOG --image="dialog-warning" "$T$MSG" "$OK" 2>/dev/null
                    ;;
        esac
    done
}

#function restoreXsettings(){
#    XBKP=""
#    for var in "$@";do
#        if [[ -e $var ]];then        # backup .bashrc & .Xresources first
#            XBKP="$var.bkp"
#            if [[ "$var" = "$SYSCONFIGPATH"/* ]] # cannot make backup in system dir
#            then
#                XBKP="${HOME}/${var##*/}.${DIR}.bkp"
#            fi
#            cp "$var" "$XBKP"
#            cp "$var" "$HOME"
#            echo -e "\n  $var backed up and restored"
#        else
#            cp "$var" "$HOME"
#            echo -e "\n  $var restored"
#        fi
#    done
#    xrdb ~/.Xresources
#}

# $1 [$2...] are relative paths passed from restoreSettings()
# THEMEPATH is global set by restoreSettings()
function restoreFiles(){
    for i in "$@"
    do
        local src_file target_file
        src_file="$THEMEPATH/user/$i"
        target_file="$HOME/$i"
        restoreFile "$src_file" "$target_file" || continue
    done
}


# $1 and $2 are explicit source and target filepaths
# THEMEPATH is global set by restoreSettings()
function restoreFile(){
    local src_file target_file target_dir bkp_file
    src_file="$1"
    [[ -r $src_file ]] || {
        echo "$0: File to restore, $src_file is not readable." >&2
        return 1
    }
    target_file="$2"
    target_dir="${target_file%/*}"
    mkdir -p "$target_dir"
    if [[ -e $target_file ]];then        # backup config first
        bkp_file="${target_file}.${NOW}.bkp"
        mv "$target_file" "$bkp_file"
        cp "$src_file" "$target_file"
        echo -e "\n  $target_file backed up and restored"
    else
        cp "$src_file" "$target_file"
        echo -e "\n  $target_file did not exist, now added"
    fi
}

function reloadGTK(){ # reload gtk theme after restoring saved config
python - <<END
import gtk

events=gtk.gdk.Event(gtk.gdk.CLIENT_EVENT)
data=gtk.gdk.atom_intern("_GTK_READ_RCFILES", False)
events.data_format=8
events.send_event=True
events.message_type=data
events.send_clientmessage_toall()

END
}

# This function is run in restoreSettings() below
# $CURRENTSESSION from getCurrent()
# DLGARR is global, but local to restoreSettings()
function ViewRestoreDialog(){   # list saved theme collections for yad as DLGARR
    getCurrent                      # get name of latest set BLOB config
    if (( NUMDIRS == 0 ));then  # no saved configs; go back to Intro dialog
        Intro
    fi
    local seticon themename thumbnail
    declare -A uniqnames # hide duplicate directories
    DLGARR=()
    i=0
    for dir in "$USRCONFIGPATH"/* "$SYSCONFIGPATH"/* ;do
        if [[ -d $dir ]];then
            if [[ -e $dir/settings.cfg ]];then
                themename="${dir##*/}" # strip path
                themename=${themename// /_}   # replace any spaces in dir name
                [[ "${uniqnames["$themename"]}" = 'found' ]] && continue
                uniqnames["$themename"]='found'
                # get name of current session, set icon for TRUE/FALSE
                if [[ $CURRENTSESSION = "$themename" ]];then
                    seticon="gtk-yes"
                elif [[ "$dir" = "$SYSCONFIGPATH"/* ]]; then
                    seticon="system"
                else
                    seticon="gtk-home"
                fi
                thumbnail="$dir/$themename-thumb.jpg"
                [[ -r $thumbnail ]] || thumbnail='None'     # placeholder if no thumbnail found
                DLGARR+=( "$seticon" "<big>$themename</big>" "$thumbnail" )
            fi
            i=$((i+1))
        fi
    done
}

function getActiveMonitorDimensions(){   # set width and height for View dialog
    declare -a dim=()
    dim=($(bl-xinerama-prop))
    DLGWIDTH=$(( dim[0] / 3 ))
    DLGHEIGHT=$(( dim[1] * 2 / 3 ))
    [[ $DLGWIDTH =~ ^[0-9]+$ ]] && [[ $DLGHEIGHT =~ ^[0-9]+$ ]] || {
        print 'Error in getActiveMonitorDimensions'
        exit 1
    }
}

########################################################################
######## Main BLOB list display function ###############################
# sets global THEMEPATH for restore functions
function restoreSettings(){ # generates global NOW
    local DLGWIDTH DLGHEIGHT DLGARR RET CONFIG themename
    getActiveMonitorDimensions
    ViewRestoreDialog # generates DLGARR
    while true ;do
        CONFIG=$($DIALOGDEC --list --title="$TITLE" \
            --text="Double-click selection, or \"Enter\", or use the \"Restore\" button to restore settings\n" \
            --separator=" " \
            --button="About:5" \
            --button="View image:4" --button="Add New:3" \
            --button="Delete:2" --button="Restore:0" --button="gtk-quit:1" \
            --always-print-result \
            --width=$DLGWIDTH --height=$DLGHEIGHT --center --image-preview \
            --expand-column=3 \
            --column="Last Set:IMG" \
            --column="Config Name":TEXT \
            --column="Screenshot":IMG \
            "${DLGARR[@]}" \
            2>/dev/null )
        RET=$?
        if [[ $CONFIG =~ '<big>'(.+)'</big>' ]];then
            themename=${BASH_REMATCH[1]}
             # If same name found, user directory will take precedence.
            if [[ -d "$USRCONFIGPATH/$themename" ]]
            then
                THEMEPATH="$USRCONFIGPATH/$themename"
            elif [[ -d "$SYSCONFIGPATH/$themename" ]]
            then
                THEMEPATH="$SYSCONFIGPATH/$themename"
            fi
        else
            echo "$0: function restoreSettings returned strange value $CONFIG" >&2
            exit 1
        fi
        case $RET in
            0)  SAVED="$THEMEPATH/LISTMSG.txt"
                TEXT="Restoring Configs saved as $CONFIG\n\n"
                TEXT="$TEXT$(< "$SAVED")"
                $DIALOG "$T$TEXT" "$CANCEL" "$OK" 2>/dev/null
                if (( $? == 0 ));then
                    echo "$themename" > "$CURSESSFILE"
                    break
                fi
                ;;
            1)  exit 0
                ;;
            2)  if [[ ! $CONFIG ]];then
                    $DIALOG --text="Make a selection before trying to delete" "$EXIT" "$OK" 2>/dev/null
                    if (( $? == 0 ));then
                        continue
                    else
                        exit 0
                    fi
                fi

                SYSDIRTXT="Sorry, system preset theme <b>${themename}</b> cannot be deleted"
                if [[ "${THEMEPATH%/*}" = "$SYSCONFIGPATH" ]]
                then
                    $DIALOG --image="dialog-warning" "$T$SYSDIRTXT" "$CLOSE" 2>/dev/null
                    continue
                fi

                TEXT="Delete saved configurations <b>$THEMEPATH</b>\nand screenshot?"
                $DIALOG "$T$TEXT" "$CANCEL" "$OK" 2>/dev/null

                if (( $? == 0 ));then
                    rm -rf "$THEMEPATH"
                    echo -e "\n$themename DELETED"
                    if [[ $(< "$CURSESSFILE") = "$themename" ]];then
                        :> "$CURSESSFILE"
                    fi
                    ViewRestoreDialog # regenerate list
                fi
                continue
                ;;
            3)  setName
                saveSettings
                getScrot
                $DIALOG --text="Settings were saved as <b>$NEWNAME</b>" --image="gtk-save" "$OK" 2>/dev/null
                if [[ -d $CONFIGDIR_BKP ]];then
                    rm -rf "$CONFIGDIR_BKP"
                    echo -e "\n  Temporary $CONFIGDIR deleted\n"
                fi
                ViewRestoreDialog
                continue
                ;;
            4)  # show screenshot in image viewer
                if [[ -n $themename ]];then
                    if [[ -r "$THEMEPATH/${themename}.jpg" ]]; then
                        img="$THEMEPATH/${themename}.jpg"
                    elif [[ -r "${THEMEPATH%/*}/${themename}.jpg" ]]; then
                        img="${THEMEPATH%/*}/${themename}.jpg"
                    else
                        echo "$0: No screenshot ${themename}.jpg found" >&2
                        continue
                    fi
                    $IMGCMD "$img"
                else
                    $DIALOG --text="Make a selection" 2>/dev/null
                fi
                continue
                ;;
            5)  Intro
                ;;
            *)  if (( RET == 252 ));then
                    echo -e "\n  Exited with \"ESC\" key"
                else
                    echo -e "\n  Error= $RET" >&2
                fi
                exit 1
                ;;
        esac
    done
    NOW=$(date +"%Y%m%d-%H%M%S") # global: restore functions will inherit
    # get chosen saved configs and restore them
    # Conky and Tint2 will be killed by their restore functions, if called.
    local TAG VAL
    while read -r TAG VAL; do #line;do
        home_marker='%USERHOME%'
        case "$TAG" in
            "[OBTHEME]"     )   if [[ $VAL ]];then
                                    checkOBTHEME "$VAL"
                                fi
                                restoreOBrc "$THEMEPATH"
                                ;;
            "[GTK]"         )   if [[ $VAL ]];then
                                    checkGTK "$VAL"
                                fi
                                restoreGTK "$THEMEPATH"
                                reloadGTK
                                ;;
            "[ICONS]"       )   if [[ $VAL ]];then
                                    checkICONS "$VAL"
                                fi
                                ;;
            "[BACKGROUND]"  )   if [[ $VAL = FEH ]];then
                                    cp "$THEMEPATH/.fehbg" "$HOME"
                                    source "$HOME/.fehbg"
                                else
                                    cp "$THEMEPATH/bg-saved.cfg" "$NITRODIR"
                                    nitrogen --restore
                                fi
                                ;;
            "[CONKY]"       )   if [[ $VAL ]];then
                                    VAL="${VAL//"$home_marker"/"$HOME"}"
                                    restoreConky "$VAL"
                                fi
                                ;;
            "[TINT2]"       )   if [[ $VAL ]];then
                                    VAL="${VAL//"$home_marker"/"$HOME"}"
                                    restoreTint2 "$VAL"
                                fi
                                ;;
            "[DMENU]"       )   restoreDmenu "$THEMEPATH/$DMENU"
                                ;;
            "[LIGHTDM]"     )   echo "Lightdm settings not supported at this time" #restoreLightdm "$THEMEPATH/$LDM"
                                ;;
            "[EXITRC]"      )   : #restoreBLexitrc "$THEMEPATH"
                                ;;
            "[XFILES]"      )   echo ".bashrc will not be overwritten: a copy is in $THEMEPATH/.bashrc"
                                restoreFiles ".Xresources" #"$THEMEPATH/.bashrc" # do not restore .bashrc for now
                                xrdb ~/.Xresources
                                ;;
#            "[TERMINATOR]"  )   restoreFile "$THEMEPATH/config" "$HOME/.config/terminator/config"
#                                ;;
            '['*']'         )   restoreFiles "$VAL"
                                ;;
            *               )   echo -e "  Unknown value!" >&2
                                restoreSettings
                                ;;
        esac
    done < "$THEMEPATH/settings.cfg"
    openbox --reconfigure
    restoreSettings
}

######################### end restore functions ########################

function cleanup(){
    if [[ $1 = all ]];then
        if [[ -d $CONFIGDIR ]];then
            rm -rf "$CONFIGDIR"
            echo -e "\n  Deleted $CONFIGDIR"
        fi
        if [[ -d $CONFIGDIR_BKP ]];then
            mv "$CONFIGDIR_BKP" "$CONFIGDIR"
            echo -e "\n  Cancelled\n..Temporary $CONFIGDIR restored\n"
        fi
        rm -f /tmp/blob.*
    elif [[ $1 = save ]];then
        saveSettings
    fi
}


### END FUNCTIONS ######################################################

# Do not run as root (Bad Things may happen).
if [[ $( id -u ) -eq 0 ]]; then
    echo $"Error: This script should not be run by root." >&2
    exit 1
fi

# test for blobthemes config directory, create if it doesn't exist
mkdir -p "$USRCONFIGPATH"

# create file to hold most recent saved configuration name
if [[ ! -f $CURSESSFILE ]];then
    touch "$CURSESSFILE"
fi

Intro

exit 0
