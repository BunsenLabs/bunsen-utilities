#!/bin/bash
#
#    bl-obthemes: script to save or restore openbox gui configurations
#    Copyright (C) 2015,2017 damo    <damo@bunsenlabs.org>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#
# Save options are for  Conky(s)
#                       Tint2(s)
#                       Openbox theme
#                       GTK theme
#                       Background (uses Nitrogen or feh, depending which
#                                   has the newer saved bg config file)
#                       Alt Menu (dmenu)
#                       Lightdm login gtk greeter (currently disabled)
#                       Exit dialog theme
#                       X configs (.bashrc, .Xresources)
#                       Terminator config
#
# Paths are assumed to be BunsenLabs defaults
#
# A Screenshot is saved (Windows are hidden briefly so the image
#                        is the bare desktop, with any Tint2s
#                        or Conkys which are running, and a representive
#                        menu and window open)
#
# A time-stamped backup of rc.xml is saved "just in case".
#
# USER VARIABLE: xdotool is used to move the mouse pointer, and assumes the
# root-menu is shown with "Super + Space" keys, and the right mouse button is
# set for "r-click". If you have set these to something else, then edit the
# "MENUMODIFIER" and "MOUSECMD" variables.
# Set the variable "KEYDOWN" to where "Preferences" is in the root-menu (or
# anything else you might want displayed).
# The image viewer is set to be "bl-image-viewer". Edit the "IMGCMD" variable
# to change this.
#
# WARNING: It is assumed that the conkys are not being run via a script, so
# they will appear on all desktops. If you usually use a script, then you
# may have to make your own arrangements! Conkys in non-default directories
# can be saved, but will not be seen when running the bl conky chooser
#
########################################################################
#
# KNOWN ISSUES:
# Virtualbox does not allow the guest to move the host mouse cursor, using xdotool,
# so the screenshot may produce an incorrect theme displayed and/or poor positioning.
# A workaround is to move the cursor to some free space, and use the "Enter" key in the
# "Configurations to be saved:" dialog.
#

HELP="bl-obthemes is a script to save or restore openbox gui configurations

Usage:  $0 [-h|--help]
Options:
        -h, --help   show this message

No other CLI options are supported.

Save options:
            Conky(s)

            Tint2(s)

            Openbox theme

            GTK theme

            Background
            (uses Nitrogen or feh, depending which has the newer saved bg config file)

            Alt Menu (dmenu)

            Lightdm login gtk greeter (currently disabled)

            Exit dialog theme

            X configs (.bashrc, .Xresources)

            Terminator config

Paths are assumed to be BunsenLabs defaults.

A Screenshot is saved
                    (Windows are hidden briefly so the image
                    is the bare desktop, with any Tint2s
                    or Conkys which are running, and a representive
                    menu and window open.)

A time-stamped backup of rc.xml is saved \"just in case\".

Configuration:

 USER VARIABLE: xdotool is used to move the mouse pointer, and assumes the
 root-menu is shown with \"Super + Space\" keys, and the right mouse button is
 set for \"r-click\". If you have set these to something else, then edit the
 \"MENUMODIFIER\" and \"MOUSECMD\" variables.
 Set the variable \"KEYDOWN\" to where \"Preferences\" is in the root-menu (or
 anything else you might want displayed).
 The image viewer is set to be \"bl-image-viewer\". Edit the \"IMGCMD\" variable
 to change this.

WARNING:
 It is assumed that the conkys are not being run via a script, so
 they will appear on all desktops. If you usually use a script, then you
 may have to make your own arrangements! Conkys in non-default directories
 can be saved, but will not be seen when running the bl conky chooser.

KNOWN ISSUES:
 Virtualbox does not allow the guest to move the host mouse cursor, using xdotool,
 so the screenshot may produce an incorrect theme displayed and/or poor positioning.
 A workaround is to move the cursor to some free space, and use the \"Enter\" key in the
 \"Configurations to be saved:\" dialog.
"
# look for a help option somewhere
for i in "$@"
do
    case "$i" in
    -h|--help)
        echo "$HELP"
        exit 0
        ;;
    esac
done

#### VARIABLES #########################################################

### USER SETTINGS
IMGCMD="bl-image-viewer"    # application command to view screenshot
MENUMODIFIER="super+space"  # keybind for show root-menu
MOUSECMD="click 3"          # mouse r-click
KEYDOWN=13           # adjust this for where "Preferences" is in the menu

### GLOBALS
CONFIGPATH="$HOME/.config/blob"
SYSCONFIGPATH="/usr/share/bunsen/utilities/blob"
CURSESSION="$CONFIGPATH/current"
OBPATH="$HOME/.config/openbox"

# globals set by setName() for storing current settings as theme
CONFIGDIR=""
SETTINGS=""
LISTMSG=""

# set by getSet() - number of stored themes
NUMDIRS=0

# packages needed for particular icon themes
declare -A icon_pkgs=(
[Faenza-Dark-Bunsen]='bunsen-faenza-icon-theme'
[Faenza-Bunsen]='bunsen-faenza-icon-theme'
[Paper-Bunsen]='bunsen-paper-icon-theme'
[Papirus-Bunsen-grey]='bunsen-papirus-icon-theme'
[Papirus-Bunsen-bluegrey]='bunsen-papirus-icon-theme'
[Papirus-Bunsen-Dark-grey]='bunsen-papirus-icon-theme'
[Papirus-Bunsen-Dark-bluegrey]='bunsen-papirus-icon-theme'
)
# theme packages
declare -A theme_pkgs=(
[Beam]=bunsen-themes
[Bunsen-He]=bunsen-themes
[Bunsen-Dark-He]=bunsen-themes
[Bunsen-He-flatish]=bunsen-themes
)

THEMEPATH_1="$HOME/.themes"
THEMEPATH_2="$HOME/.local/share/themes"
THEMEPATH_3="/usr/share/themes"
THEMEPATH_4="/usr/local/share/themes"
gtkPaths=("$THEMEPATH_1" "$THEMEPATH_2" "$THEMEPATH_3" "$THEMEPATH_4")

ICONPATH_1="$HOME/.icons"
ICONPATH_2="$HOME/.local/share/icons"
ICONPATH_3="/usr/share/icons"
ICONPATH_4="/usr/local/share/icons"
iconPaths=("$ICONPATH_1" "$ICONPATH_2" "$ICONPATH_3" "$ICONPATH_4")

### CONFIGS VARIABLES
EXITDIR="$HOME/.config/bl-exit"
SYSEXITDIR="/etc/bl-exit"
TERMDIR="$HOME/.config/terminator"
TERMFILE="$TERMDIR/config"
FEHFILE="$HOME/.fehbg"
NITRODIR="$HOME/.config/nitrogen"
NITROFILE="$NITRODIR/bg-saved.cfg"
CONKYPATH="$HOME/.config/conky"
CONKYSESSION="$CONKYPATH/conky-sessionfile"
TINTSESSION="$HOME/.config/tint2/tint2-sessionfile"
GTK2=".gtkrc-2.0"
GTK2MINE=".gtkrc-2.0.mine"
GTK3="$HOME/.config/gtk-3.0"
GTK3x="$HOME/.config/xfce4/xfconf/xfce-perchannel-xml/xfce4-notifyd.xml"
DMENUDIR="$HOME/.config/dmenu"
DMENU="dmenu-bind.sh"
XFILE=".Xresources"
BASHFILE=".bashrc"
LDMDIR="/etc/lightdm"
LDM="lightdm-gtk-greeter.conf"

### END CONFIGS VARIABLES

### DIALOG VARIABLES
DIALOG="yad --center --undecorated --borders=20 --window-icon=distributor-logo-bunsenlabs --fixed"
DIALOGDEC="yad --center  --borders=20 --window-icon=distributor-logo-bunsenlabs"
TITLE="BLOB Configuration Manager"
T="--text="
OK="--button=OK:0"
CANCEL="--button=gtk-cancel:1"
EXIT="--button=gtk-quit:1"
CLOSE="--button=gtk-close:1"
TXTINTRO='<big><b>BunsenLabs
Openbox Configuration Manager</b></big>


<b>Save or Restore settings for:</b>

    Openbox theme
    GTK theme
    Conkys
    Tint2
    Desktop Background
    Alt Menu (dmenu)
    LightDM theme (currently disabled)
    Exit dialog theme
    X configs (.bashrc, .Xresources)
    Terminator (if default term)
    + Screenshot'

PICKOB="OB theme"
PICKGTK="GTK theme"
PICKCONKY="Conky"
PICKTINT="Tint2"
PICKBG="Background Wallpaper"
PICKDMENU="dmenu (Alt menu)"
PICKLDM="Lightdm Login theme"
PICKEXIT="Exit dialog theme"
PICKTERM="Terminator"
PICKX="X configs"

### END DIALOG VARIABLES

#### END VARIABLES #####################################################

### FUNCTIONS ##########################################################

function Intro(){
    local RET
    getSet
    #  if blob/ is empty, then don't display "View Saved" option in Intro dialog
    if (( NUMDIRS > 0 ));then
        $DIALOGDEC "$T$TXTINTRO" \
        --title="$TITLE" \
        --button="Save Settings:0" --button="View Saved:2" $CLOSE \
        --borders=30 \
        2>/dev/null
    else
        $DIALOGDEC \
        --title="$TITLE" \
        "$T$TXTINTRO" \
        --button="Save Settings:0" $CLOSE \
        --borders=30 \
        2>/dev/null
    fi
    RET=$?
    case $RET in
        0)  setName
            saveSettings
            getScrot
            if [[ -d $CONFIGDIR_BKP ]];then
                rm -rf "$CONFIGDIR_BKP"
                echo -e "\n  Temporary $CONFIGDIR deleted\n"
            fi
            restoreSettings
            ;;
        1)  echo "CANCELLED..."
            exit 0
            ;;
        2)  getSet
            restoreSettings
            ;;
        *)  echo "RETURN ERROR" 2>&1
            ;;
    esac
}

# sets globals NUMDIRS and SET
function getSet(){      # get name of currently set BLOB config
    local dirs
    NUMDIRS=0
    shopt -s nullglob
    dirs=( "$CONFIGPATH"/*/ "$SYSCONFIGPATH"/*/ )
    NUMDIRS=${#dirs[@]}
    shopt -u nullglob
    if (( NUMDIRS == 0 ));then
        if [[ -f $CURSESSION ]];then
            rm "$CURSESSION"
        fi
    elif (( NUMDIRS > 0 )) && [[ -f $CURSESSION ]];then
        SET=$(< "$CURSESSION")
    fi
}

function getActiveMonitorDimensions(){   # set width and height for View dialog
    declare -a dim=()
    dim=($(bl-xinerama-prop))
    W=$(( dim[0] / 3 ))
    H=$(( dim[1] * 2 / 3 ))
    [[ $W =~ ^[0-9]+$ ]] && [[ $H =~ ^[0-9]+$ ]] || {
        print 'Error in getActiveMonitorDimensions'
        exit 1
    }
}

# sets globals CONFIGDIR SETTINGS LISTMSG for storing new theme
function setName(){  # set name of collection, make dir and session settings file
    MSG="  Configurations will be saved to a new directory in  \
    \n  $CONFIGPATH\n\n  Enter name of new collection...  "
    MSG2="  No file specified for new saved session.\n\n  Try again?"
    LOOP=1
    DEL=0
    while [[ $LOOP ]];do  # loop dialog if nothing is selected
        ANS=$($DIALOG --entry \
            $CANCEL --button="OK:0" \
            "$T$MSG" \
            2>/dev/null )
        if (( $? == 1 )) ;then # Cancel was selected
            Intro
        elif [[ ! $ANS ]] ;then     # entry was empty
            $DIALOG --image="dialog-question" \
            "$CANCEL" "$OK" \
            "$T$MSG2" \
            2>/dev/null
            RET=$?
            echo -e "\n  No name entered for new collection!" 2>&1
            if (( RET == 0 ));then
                continue
            else
                Intro
            fi
        else
            ANS=${ANS// /_}    # replace any spaces in dir name
            CONFIGDIR="$CONFIGPATH/$ANS"
            if [[ -d $CONFIGDIR ]];then
                echo -e "\n  $CONFIGDIR already exists"

                $DIALOG --form --image="dialog-question" \
                --text="Overwrite existing saved session?" \
                "$CANCEL" "$OK" \
                --width=300 \
                2>/dev/null

                if (( $? == 0 ));then
                    mv "$CONFIGDIR" "$CONFIGDIR_BKP" && mkdir -p "$CONFIGDIR"
                    DEL=1
                    SETTINGS="$CONFIGDIR/settings.cfg"
                    :> "$SETTINGS"
                    LISTMSG="$CONFIGDIR/LISTMSG.txt"
                    :> "$LISTMSG"
                    break
                else
                    continue
                fi
            fi
            mkdir -p "$CONFIGDIR"
            SETTINGS="$CONFIGDIR/settings.cfg"
            LISTMSG="$CONFIGDIR/LISTMSG.txt"
            :> "$SETTINGS"
            :> "$LISTMSG"
            break
        fi
    done
    setText
}

function setText(){
    TIME=$(date)
    if (( DEL == 1 ));then
        TXT="  (Existing session overwritten)"
    else
        TXT=""
    fi
    echo -e "\n  Configuration will be saved as: $ANS$TXT"
    echo -e "<b>Configuration name: $ANS</b>\t$TXT\nSaved at $TIME\n" >> "$LISTMSG"
}

function getBg(){    # find if feh or nitrogen was used. Save config file(s)
    if [[ -e $NITROFILE ]] && [[ -e $FEHFILE ]];then  # see which was last used to set background
        if [[ $NITROFILE -nt $FEHFILE ]];then # use most recent method
            BGSET="NITROGEN"
        else
            BGSET="FEH"
        fi
    elif [[ -e $FEHFILE ]] && [[ ! -e $NITROFILE ]];then  # use feh for background
        BGSET="FEH"
    elif [[ -e $NITROFILE ]] &&  [[ ! -e $FEHFILE ]];then    # use nitrogen for background
        BGSET="NITROGEN"
    else
        echo -e "\n  No background-setting application found" 2>&1
        BGSET="None"
    fi
    echo -e "\n  Background to be set with $BGSET"
    case "$BGSET" in
        FEH     )   echo "[BACKGROUND] $BGSET" >> "$SETTINGS"
                    cp "$FEHFILE" "$CONFIGDIR"
                    echo -e "\n  $FEHFILE copied"
                    getFeh
                    ;;
        NITROGEN)   echo "[BACKGROUND] $BGSET" >> "$SETTINGS"
                    cp "$NITROFILE" "$CONFIGDIR"
                    echo -e "\n  Saved Nitrogen file: $NITROFILE"
                    getNitrogen
                    ;;
        None    )   echo -e "\n  No background-setting application found" 2>&1
                    echo "[BACKGROUND] $BGSET" >> "$SETTINGS"
                    ;;
        *       )   echo -e "\n  ERROR: No background config found" 2>&1
                    exit 1
                    ;;
    esac
}

function getFeh(){    # get Feh saved backgrounds
    local FFILE="$CONFIGDIR/.fehbg"
    if [[ -f $FFILE ]];then
        local BG=""
        # get fields between single quotes
        while read -r line;do
            BG="$BG$line;\n\t"
        done < <(grep -o "'[^']*'" "$FFILE" | sed "s/'//g" 2>/dev/null)
        echo -e "\n  Backgrounds set with Feh, using:\t$FEHFILE"
        echo -e "\t$BG"
        echo -e "Background set with feh:\n\t$BG" >> "$LISTMSG"
    else
        echo -e "\n  $FFILE not found" 2>&1
    fi
}

function getNitrogen(){  # get Nitrogen saved backgrounds
    local NFILE="$CONFIGDIR/bg-saved.cfg"
    if [[ -f $NFILE ]];then
        local BG=""
        while read -r line;do
            [[ $line = 'file='* ]] || continue
            BG="$BG${line#file=};\n\t"
        done < "$NFILE"
        echo -e "\n  Backgrounds set with Nitrogen, using:\t$NITROFILE"
        echo -e "\t$BG"
        echo -e "Background set with nitrogen:\n\t$BG" >> "$LISTMSG"
    else
        echo -e "\n  $NFILE not found" 2>&1
    fi
}

# get command from window id (passed as $1)
function getConkyCmd() {
    local id wmc cmd
    id=$1
    wmc=$(xprop -id "$id"  WM_COMMAND)
    wmc=${wmc#*\"} # strip first & last quotes & everything outside
    wmc=${wmc%\"*}
    cmd=${wmc%% *} # separate first word
    cmd=${cmd%\"*}
    [[ $cmd = conky ]] || { echo "$0: Window id $id command $cmd is not conky" >&2; return 1;}
    awk -F '", "' '{
        for (i=1;i<=NF;i++){
            gsub(/\\\"/,"\"",$i)
            printf "%s ", $i
        }
    }' <<< "$wmc"
}

function getConky(){
    local CONKYCMD=""
    LISTMSGTXT="Running Conkys:"
    CMDTXT="[CONKY] "
    CONKYTXT=""
    NUM_DESKTOPS=$(xdotool get_num_desktops)

    local -A arrSTICKY
    if [[ $(pidof conky) ]];then
        while read -r id;do  # get all running conky id's
            arrSTICKY["$id"]=1
        done < <(xdotool search --class conky)

        for (( i=0; i<NUM_DESKTOPS; i++ ));do  # get all conkys running on specific desktops
            while read -r id;do
                unset arrSTICKY["$id"] # remove from sticky list
                if ! [[ -z "$id" ]];then
                    CONKYCMD=$(getConkyCmd "$id")
                    if [[ "$CONKYCMD" == "conky" ]] || [[ "$CONKYCMD" == "conky -q" ]];then
                        CONKYTXT="$CONKYTXT\n\tDesktop $i:  Default Conky"
                    else
                        CONKYTXT="$CONKYTXT\n\tDesktop $i:  $CONKYCMD"
                    fi
                    # command to start on specified desktop with wmctrl
                    CONKYCMD="sleep 1 && wmctrl -s $i && $CONKYCMD &;"
                    CMDTXT="$CMDTXT$CONKYCMD"
                fi
            done < <(xdotool search --desktop $i --class conky)
        done

        for id in "${!arrSTICKY[@]}";do  # get commands - we don't need wmctrl for these
            if ! [[ -z "$id" ]];then
                CONKYCMD=$(getConkyCmd "$id")
                if [[ "$CONKYCMD" == "conky" ]] || [[ "$CONKYCMD" == "conky -q" ]];then
                    CONKYTXT="$CONKYTXT\n\tDefault Conky"
                else
                    CONKYTXT="$CONKYTXT\n\t$CONKYCMD"
                fi
                CONKYCMD="sleep 1 && $CONKYCMD &;"
                CMDTXT="$CMDTXT$CONKYCMD"
            fi
        done
        echo "$CMDTXT" >> "$SETTINGS"
        echo -e "$LISTMSGTXT\t$CONKYTXT\n" >> "$LISTMSG"
        echo -e "\n  Saved running Conky(s)"
    else
        DLG=$($DIALOG --form --image="dialog-warning" \
        --text="You selected to save Conkys\nbut none are running" \
        "$OK" \
        --width=300) 2>/dev/null
    fi
    }

function getTint(){
    declare -a arrTINT
    if [[ $(pidof tint2) ]];then
        while read -r pid cmd;do
            if [[ ${cmd%% *} == tint2 ]];then
                TPATH=$(echo "$cmd" | awk '{print $NF";"}')
                arrTINT+=("$TPATH")
            fi
        done < <(pgrep -a tint2)

        TXT="Tint2s:\n\n"
        MSG="Running Tint2s:"
        TINTCMD=""
        LISTMSGTXT=""

        for i in "${arrTINT[@]}";do
            TXT="$TXT$i"
            TINT=${i//;}
            if [[ "$TINT" == "tint2" ]];then
                TINTCMD="$TINTCMD$TINT;"
                LISTMSGTXT="$LISTMSGTXT\n\tDefault Tint2"
            else
                TINTCMD="$TINTCMD$TINT;"
                LISTMSGTXT="$LISTMSGTXT\n\t$TINT"
            fi
        done

        echo "[TINT2] $TINTCMD" >> "$SETTINGS"
        echo -e "$MSG\t$LISTMSGTXT\n" >> "$LISTMSG"
        echo -e "\n  Saved running Tint2(s)"
    else
        DLG=$($DIALOG --form --image="dialog-warning" \
        --text="You selected to save Tint2\nbut none are running" \
        "$OK" \
        --width=300) 2>/dev/null
    fi
}

function killTints(){
    pgrep -a tint2 | while read -r pid cmd; do
        if [[ ${cmd%% *} = tint2 ]]; then
            kill "$pid"
        fi
    done
}

function getOBtheme(){   # copy <theme> section from rc.xml to obtheme.txt
    RCFILE="$OBPATH/rc.xml"
    tag="theme"
    sed -n "/<$tag>/,/<\/$tag>/p" "$RCFILE" > "$CONFIGDIR/obtheme.txt"
    getOBname
    echo "[OBTHEME] $OBTHEME" >> "$SETTINGS"
}

function getOBname(){    # get Openbox theme name
    OBFILE="$CONFIGDIR/obtheme.txt"
    OBTHEME=$(awk 'NR==2 {print;exit}' "$OBFILE" | awk -F'[>|<]' '{print $3}')
    TXT="Openbox theme:  $OBTHEME\n"
    echo -e "\n  Saved $TXT"
    echo "$TXT" >> "$LISTMSG"
}

function getGTKtheme(){
    GTKTHEMES=( "$HOME/$GTK2" "$HOME/$GTK2MINE" "$GTK3" "$GTK3x" )
    for f in "${GTKTHEMES[@]}";do
        if [[ -f $f ]];then
            cp "$f" "$CONFIGDIR"
        elif [[ -d $f ]];then
            GTKDIR="$CONFIGDIR/$(basename "$f")"
            mkdir -p "$GTKDIR"
            cp "$f/settings.ini" "$GTKDIR"
            cp "$f/gtk.css" "$GTKDIR"
        fi
    done
    getGTKname
}

function getGTKname(){   # get GTK theme name and Icons name
    GTKFILE="$CONFIGDIR/.gtkrc-2.0"
    while read -r line;do
        if [[ $line = *"gtk-theme-name"* ]];then
            GTKTHEME=$(awk -F '"' '{print $2}' <<< "$line")
            echo "[GTK] $GTKTHEME" >> "$SETTINGS"
        fi
        if [[ $line = *"gtk-icon-theme-name"* ]];then
            ICONS=$(awk -F '"' '{print $2}' <<< "$line")
            echo "[ICONS] $ICONS" >> "$SETTINGS"
        fi
    done < "$GTKFILE"
    TXT="GTK theme:  $GTKTHEME;  Icon Theme: $ICONS\n"
    echo -e "\n  Saved $TXT"
    echo  "$TXT" >> "$LISTMSG"
}

function getDmenu(){
    if [[ -d $DMENUDIR ]];then
        cp "$DMENUDIR/$DMENU" "$CONFIGDIR"
        echo "[DMENU]" >> "$SETTINGS"
        TXT="dmenu config:  $DMENUDIR/$DMENU\n"
        echo -e "\n  Saved $TXT"
        echo "$TXT" >> "$LISTMSG"
    else
        echo "  $DMENUDIR/$DMENU not found"
    fi
}

function getLightdm(){
    if [[ -f $LDMDIR/$LDM ]];then
        cp "$LDMDIR/$LDM" "$CONFIGDIR"
        TXT="Lightdm config:  $LDMDIR/$LDM\n"
        echo -e "\n  Saved $TXT"
        echo "[LIGHTDM]" >> "$SETTINGS"
        echo "$TXT" >> "$LISTMSG"
    fi
}

function getTerminator(){
    if [[ -e $TERMFILE ]];then
        cp "$TERMFILE" "$CONFIGDIR"
        TXT="Terminator config:  $TERMFILE\n"
        echo -e "\n  Saved $TXT"
        echo "[TERMINATOR]" >> "$SETTINGS"
        echo "$TXT" >> "$LISTMSG"
    fi
}

function getXconfig(){
    XFILE="$HOME/.Xresources"
    BASHFILE="$HOME/.bashrc"
    if [[ -f $XFILE ]];then
        cp "$XFILE" "$CONFIGDIR"
    fi
    if [[ -f $BASHFILE ]];then
        cp "$BASHFILE" "$CONFIGDIR"
    fi
    TXT="X terminal config:  $BASHFILE; $XFILE ($BASHFILE will not be auto-restored)\n"
    echo -e "\n  Saved $TXT"
    echo "[XFILES]" >> "$SETTINGS"
    echo "$TXT" >> "$LISTMSG"
}

function getBLexitrc(){
    if [[ -d $EXITDIR ]];then # whole directory is needed
        cp -r "$EXITDIR" "$CONFIGDIR"
    else
        echo "$EXITDIR not found, using default settings"
        cp -r "$SYSEXITDIR" "$CONFIGDIR"
    fi
    echo "[EXITRC]" >> "$SETTINGS"
    TXT="bl-exitrc config:  $EXITDIR\n"
    echo -e "\n  Saved $TXT"
    echo "$TXT" >> "$LISTMSG"
}

function checkTint2(){   # kill or restart tint2s for screenshot, if necessary
    if [[ $1 = stop ]];then
        if ! grep "TINT2" "$SETTINGS" &>/dev/null;then
            tmpTINT=$(mktemp --tmpdir blob.XXXX) # make blank tempfile, to save running tint2 paths
            if [[ $(pidof tint2) ]];then
                pgrep -a tint2 | while read -r pid cmd;do
                    if [[ ${cmd%% *} = tint2 ]];then
                        echo "$cmd" >> "$tmpTINT"
                    fi
                done
            fi
            killTints
        fi
    fi
    if [[ $1 = start ]];then
        if [[ -f "$tmpTINT" ]] 2>/dev/null;then
            while read -r line;do
                ($line &) &>/dev/null
                sleep 1s
            done < "$tmpTINT"
            rm -f "$tmpTINT"
        fi
    fi
}

function getWINDOWS(){  # Minimize/Activate windows for scrot. Args= 'min', 'raise', 'all'
    declare -a arrWINDOWS

    xdoFN() { echo "$0: xdoFN() not set" >&2; exit 1; }
    if [[ "$1" == "min" ]];then
        xdoFN() { xdotool windowminimize "$1";}
    elif [[ "$1" == "raise" ]] || [[ "$1" == "all" ]];then
        xdoFN() { xdotool windowactivate --sync "$1";}
    fi

    # get window id's on current desktop, which aren't sticky; convert hexcode to int.
    # add window ids to array, if not conky
    dtop=$(xdotool get_desktop)
    while read -r id dt _
    do
        [[ $dt = "$dtop" ]] || continue
        arrWINDOWS+=($(( id )))
    done < <(wmctrl -l)

    # minimize/activate non-conky windows
    conk="$(xdotool search --desktop "$dtop" --class 'Conky')"
    for win in "${arrWINDOWS[@]}";do
        if ! [[ $win = "$conk" ]];then
            ( xdoFN "$win" ) 2>/dev/null
        fi
    done
    if [[ "$1" == "all" ]];then # activate any hidden conkys
        for CONK in $(xdotool search --class 'Conky');do
            xdotool windowactivate "$CONK" 2>/dev/null
        done
    fi
}

function getScrot(){
    local conkyFLAG currDESKTOP #pid
    conkyFLAG=1
    currDESKTOP=$(xprop -root _NET_CURRENT_DESKTOP | tail -c -2)
    SCROT="$CONFIGPATH/$ANS"
    MONS=$(xrandr -q | grep -c " connected")    # number of monitors
    # set mouse position, for appearance of root-menu
    screenW=$(xrandr -q | awk '/Screen/ {print $8}')
    screenH=$(xrandr -q | awk '/Screen/ {print $10}')
    screenH=${screenH%,}

    if (( MONS == 1 ));then # single monitor
        appX=$(( (screenW/20)*8 ))
        menuX=$(( (screenW/20)*2 ))
    else
        appX=$(( (screenW/20)*4 ))
        menuX=$(( (screenW/20)*1 ))
    fi
    appY=$(( (screenH/20)*4 ))
    menuY=$(( (screenH/20)*4 ))

    if ! grep "CONKY" "$SETTINGS" &>/dev/null;then    # Conkys not to be saved
        wmctrl -k on    # hide windows, show desktop
        conkyFLAG=0
    else                # Conkys will be saved, so don't hide them for the scrot
        getWINDOWS min  # minimize windows
    fi
    checkTint2 stop     # stop running Tint2s for the scrot, if not selected to be saved
    # start lxappearance
    lxappearance 2>/dev/null &
    sleep 0.5
    # get lx window, make sure it loses focus, then move mouse and start root-menu
    LX=$(xdotool getwindowfocus)
    xdotool windowmove --sync "$LX" "$appX" "$appY" && sleep 0.1 && \
    xdotool mousemove --sync --window "$LX" -- -50 0 && xdotool click 1
    xdotool mousemove --sync "$menuX" "$menuY" && xdotool key --clearmodifiers "$MENUMODIFIER"

    i=1
    while (( i <= KEYDOWN ));do
        xdotool key --delay 50 Down
        i=$(( i+1 ))
    done
    xdotool key --delay 20 Right && sleep 0.3

    # take scrot
    scrot -t 9 "$SCROT.jpg"    # scrot thumbnail @9% fullsize
    THUMB=$(find "$CONFIGPATH" -maxdepth 1 -type f -name "*-thumb.jpg" 2>/dev/null)
    mv "$THUMB" "$CONFIGDIR"

    # close root menu
    xdotool mousemove_relative --sync --polar 0 10 $MOUSECMD
    # kill lxappearance
    pkill -P "$$" lxappearance

    # restore hidden windows
    if (( conkyFLAG == 0 ));then
        getWINDOWS all              # including hidden conkys
    else
        getWINDOWS raise            # Conkys weren't closed for scrot
    fi
    wmctrl -s "$currDESKTOP" # return to desktop that BLOB was started on, if conkys used 'wmctrl -s'
    checkTint2 start                # restore any stopped Tint2s
}

function checkICONS(){ # check if icon theme is still present
    local FOUNDICONS=0
    local ICOTXT="Icon theme <b>$1</b> not found\n\n  The default icon theme will be used..."
    for i in "${iconPaths[@]}";do # iconPaths defined at top
        if [[ -d "$i/$1" ]];then
            echo -e "\n  Found $1 icon theme"
            FOUNDICONS=1
            break
        fi
    done
    if (( FOUNDICONS == 0 ));then
        local pkg="${icon_pkgs[$1]}"
        if [[ -n "${pkg}" ]] && hash bl-install >/dev/null
        then
            echo -e "\n  Icon theme  $1  was not found\n  Offering to install $pkg..."
            local INSTICOTXT="Needed icon theme <b>$1</b> not found\n Would you like to install the package <b>${pkg}</b> which contains that theme?"
            $DIALOG --image="dialog-question" "$T$INSTICOTXT" "CANCEL" "OK" 2>/dev/null
            if (( $? == 0 ))
            then
                local retfile retval
                retfile="$( mktemp )"
                bl-install -f "$retfile" "$pkg"
                wait $!
                retval="$(<"$retfile")"
                rm "$retfile"
                if [[ "$retval" = 0 ]]
                then
                    return 0
                else
                    $DIALOG --image="dialog-warning" "${T}Install failed." "$CLOSE" 2>/dev/null
                fi
            fi
        fi
        echo -e "\n  Icon theme  $1  was not found\n  The default Icon theme will be used..."
        $DIALOG --image="dialog-warning" "$T$ICOTXT" "$CLOSE" 2>/dev/null
    fi
}

function checkGTK(){    # check if gtk theme is still present
    local FOUNDGTK=0
    local GTKTXT="GTK theme <b>$1</b> not found\n\n  The default GTK theme will be used..."
    for i in "${gtkPaths[@]}";do # gtkPaths defined at top
        if [[ -d "$i/$1" ]];then
            echo -e "\n  Found $1 GTK theme"
            FOUNDGTK=1
            break
        fi
    done
    if (( FOUNDGTK == 0 ));then
        local pkg="${theme_pkgs[$1]}"
        if [[ -n "${pkg}" ]] && hash bl-install >/dev/null
        then
            echo -e "\n  GTK theme  $1  was not found\n  Offering to install $pkg..."
            local INSTGTKTXT="Needed GTK theme <b>$1</b> not found\n Would you like to install the package <b>${pkg}</b> which contains that theme?"
            $DIALOG --image="dialog-question" "$T$INSTGTKTXT" "CANCEL" "OK" 2>/dev/null
            if (( $? == 0 ))
            then
                local retfile retval
                retfile="$( mktemp )"
                bl-install -f "$retfile" "$pkg"
                retval="$(<"$retfile")"
                rm "$retfile"
                if [[ "$retval" = 0 ]]
                then
                    return 0
                else
                    $DIALOG --image="dialog-warning" "${T}Install failed." "$CLOSE" 2>/dev/null
                fi
            fi
        fi
        echo -e "\n  GTK theme  $1  was not found\n  The default GTK theme will be used..."
        $DIALOG --image="dialog-warning" "$T$GTKTXT" "$CLOSE" 2>/dev/null
    fi
}

function restoreGTK(){   # arg is chosen saved config dir
    GTKPATHS=( "$HOME" "$HOME" "$GTK3" "$GTK3x" )
    GTKSAVED=( "$1/$GTK2" "$1/$GTK2MINE" "$1/gtk-3.0" "$1/xfce4-notifyd.xml" )
    i=0
    for f in "${GTKSAVED[@]}";do
        if [[ -e $f ]];then     # if destination exists
            if [[ -e ${GTKPATHS[i]} ]];then
                if [[ ${GTKSAVED[i]} = $1/gtk-3.0 ]];then
                    cp "${GTKSAVED[i]}"/* "${GTKPATHS[i]}" # restore contents of gtk-3.0
                    echo -e "\n  Restored gtk-3.0 files"
                else
                    cp "${GTKSAVED[i]}" "${GTKPATHS[i]}"
                    echo -e "\n  Restored: ${GTKSAVED[i]}"
                fi
            else
                echo -e "\n  Restore path ${GTKPATHS[i]} not found" 2>&1
            fi
        else
            echo -e "\n  ${GTKSAVED[i]} not found" 2>&1
        fi
        i=$((i+1))
    done
}

function checkOBTHEME(){
    local FOUNDOB=0
    local OBTXT="Openbox theme <b>$1</b> not found\n\n  The default Openbox theme will be used..."
    local arrOB=("$THEMEPATH_1" "$THEMEPATH_2" "$THEMEPATH_3" "$THEMEPATH_4" )

    for i in "${arrOB[@]}";do
        if [[ -d "$i/$1" ]];then
            echo -e "\n  Found $1 Openbox theme"
            FOUNDOB=1
            break
        fi
    done
    if (( FOUNDOB == 0 ));then
        echo -e "\n  OB theme  $1  was not found\n  The default Openbox theme will be used..."
        $DIALOG --image="dialog-warning" "$T$OBTXT" "$CLOSE" 2>/dev/null
    fi
}

function restoreOBrc(){
    RCFILE="$OBPATH/rc.xml"
    THEMEFILE="$1/obtheme.txt"
    FTEMP=$(mktemp --tmpdir blob.XXXX)
    if grep -q '[OBTHEME]' "$1/settings.cfg" ;then
        # backup rc.xml first
        NOW=$(date +"%Y%m%d-%H%M%S")
        RCBKP="$RCFILE.blob.$NOW"
        cp "$RCFILE" "$RCBKP"
        # remove older backups
        for f in $(find "$OBPATH" -type f|grep .blob. );do
            if [[ $f -ot $RCBKP ]];then
                rm "$f"
            fi
        done
        ## put placeholder in place of <theme> section, write to tempfile
        sed -n "/<theme>/{:a;N;/<\/theme>/!ba;N;s/.*\n/THEMESECTION\n/};p" "$RCFILE" > "$FTEMP"
        # replace placeholder from theme file
        sed -i "/THEMESECTION/{
            s/THEMESECTION//g
            r $THEMEFILE
        }" "$FTEMP"
        sed -i '/^$/d' "$FTEMP"   # remove empty lines
        cp "$FTEMP" "$RCFILE"     # overwrite rc.xml
        echo -e "\n  rc.xml backed up and edited for OB theme"
        rm -f "$FTEMP"
    fi
}

function restoreConky(){    # arg = $VAL from $SETCFG in restoreSettings()
    local currDESKTOP CONKYCMD
    currDESKTOP=$(xprop -root _NET_CURRENT_DESKTOP | tail -c -2)   # Conkys may have been started on different desktops
    CONKYCMD="$1"
    if type bl-conkyzen &>/dev/null;then    # see if bl-conkyzen is installed
        if [[ -f $CONKYSESSION ]] &>/dev/null; then
            :> "$CONKYSESSION" # create/overwrite conky session file
            # write to conky session file...
            echo "${CONKYCMD//;/$'\n'}" >> "$CONKYSESSION"
            killall conky
            source "$CONKYSESSION"  # run conky commands
            wait
        fi
    else
        killall conky
        eval "$CONKYCMD"    # no bl-conkyzen, so just run conky commands
        wait
    fi
    echo -e "\n  Restored Conky\n"
    wmctrl -s "$currDESKTOP" && sleep 1 # return to desktop that BLOB was started on, if conkys used 'wmctrl -s'
}

function restoreTint2(){    # arg = $VAL from $SETCFG in restoreSettings()
    TINTCMD="${VAL//;/$'\n'}"
    if type bl-tint2zen >/dev/null;then    # see if bl-tint2zen is installed
        if [[ -f $TINTSESSION ]] 2>/dev/null; then
            :> "$TINTSESSION"    # create/overwrite tint2 session file
            # write to tint2 session file...
            echo "$TINTCMD" >> "$TINTSESSION"
            killTints
            while read -r tintline;do
                if [[ "$tintline" == "tint2" ]];then
                    tint2 >/dev/null 2>&1 &
                    sleep 1
                    echo -e "\n  Restored Tint2: $tintline\n"
                elif [[ -n "$tintline" ]];then
                    tint2 -c "$tintline" >/dev/null 2>&1 &
                    sleep 1s
                    echo -e "\n  Restored Tint2: $tintline\n"
                fi
            done < "$TINTSESSION"
        fi
    else                    # no bl-tint2zen, so just run tint2 commands
        killTints
        for tintpath in $TINTCMD;do
            if [[ "$tintpath" == "tint2" ]] >/dev/null;then
                tint2 >/dev/null 2>&1 &     # default tint2 command
                sleep 1
                echo -e "\n  Restored Tint2: $tintpath\n"
            else
                tint2 -c "$tintpath" >/dev/null 2>&1 &
                sleep 1s
                echo -e "\n  Restored Tint2: $tintpath\n"
            fi
        done
    fi
}

function restoreDmenu(){
    DFILE="$1"
    if [[ -e $DMENUDIR ]];then        # backup DMENU first
        DMENUBKP="$DMENUDIR/$DMENU.bkp"
        cp "$DMENUDIR/$DMENU" "$DMENUBKP"
        cp "$DFILE" "$DMENUDIR"
        echo -e "\n  $DMENUDIR/$DMENU backed up and restored"
    else
        cp "$DFILE" "$DMENUDIR/$DMENU"
        echo -e "\n  $DMENUDIR/$DMENU restored"
    fi
}

# $1 is path to theme config dir, from $FPATH by restoreSettings()
# $NOW is global, set by restoreSettings()
function restoreBLexitrc(){
    local CONFPATH=$1
    local CONFEXITDIR="$1/bl-exit"
    local themename=${CONFPATH##*/}
    local bkp_sfx="-${themename}-${NOW}.bkp"
    if [[ "$CONFEXITDIR" = "$SYSCONFIGPATH"/* ]] # cannot make backup in system dir
    then
        EXITDIRBKP="${EXITDIR}.bkp"
    else
        EXITDIRBKP="${CONFEXITDIR}.bkp"
    fi
    if [[ -d ${CONFEXITDIR} ]]
    then
        rsync --recursive --checksum --backup --suffix="$bkp_sfx" --backup-dir="${EXITDIRBKP}" "${CONFEXITDIR}"/ "$EXITDIR"
    elif [[ -f $CONFPATH/bl-exitrc ]] # old-style user blobtheme dir
    then
        cp -r --no-clobber "$SYSEXITDIR" "$EXITDIR"
        mkdir -p "$EXITDIRBKP"
        [[ -f "$EXITDIR/bl-exitrc" ]] && cp "$EXITDIR/bl-exitrc" "$EXITDIRBKP/bl-exitrc${bkp_sfx}"
        cp "$CONFPATH/bl-exitrc" "$EXITDIR"
    else
        echo "No bl-exit theme files found." >&2
    fi
    echo -e "\n  $EXITDIR backed up and restored"
}

## TODO: use pkexec instead of gksudo
function restoreLightdm(){   # need sudo to restore lightdm-gtk-greeter.conf
    CMD="cp $1 $LDMDIR/$LDM"
    TXT="Authenticate restore of lightdm-gtk-greeter.conf"
    LOOP=1
    while [[ $LOOP ]];do
        gksudo -m "$TXT" "$CMD"
        DLG=$?
        case "$DLG" in
            0   )   MSG="Restored: lightdm-gtk-greeter.conf"
                    echo -e "\n  $MSG"
                    break
                    ;;
            255 )   MSG="  Authentication cancelled\n\nlightdm-gtk-greeter.conf was not restored"
                    echo -e "\n  $MSG" 2>&1
                    break
                    ;;
            *   )   MSG="  Password input failed\n\nlightdm-gtk-greeter.conf was not restored"
                    echo -e "\n  $MSG" 2>&1
                    $DIALOG --image="dialog-warning" "$T$MSG" "$OK" 2>/dev/null
                    ;;
        esac
    done
}

function restoreXsettings(){
    XBKP=""
    for var in "$@";do
        if [[ -e $var ]];then        # backup .bashrc & .Xresources first
            XBKP="$var.bkp"
            if [[ "$var" = "$SYSCONFIGPATH"/* ]] # cannot make backup in system dir
            then
                XBKP="${HOME}/${var##*/}.${DIR}.bkp"
            fi
            cp "$var" "$XBKP"
            cp "$var" "$HOME"
            echo -e "\n  $var backed up and restored"
        else
            cp "$var" "$HOME"
            echo -e "\n  $var restored"
        fi
    done
    xrdb ~/.Xresources
}

function restoreTerminator(){
    TFILE="$1"
    if [[ -e $TERMFILE ]];then        # backup terminator/config first
        TERMBKP="$TERMDIR/config.bkp"
        mv "$TERMFILE" "$TERMBKP"
        cp "$TFILE" "$TERMFILE"
        echo -e "\n  $TERMFILE backed up and restored"
    else
        cp "$TFILE" "$TERMFILE"
        echo -e "\n  $TERMFILE restored"
    fi
}

function reloadGTK(){ # reload gtk theme after restoring saved config
python - <<END
import gtk

events=gtk.gdk.Event(gtk.gdk.CLIENT_EVENT)
data=gtk.gdk.atom_intern("_GTK_READ_RCFILES", False)
events.data_format=8
events.send_event=True
events.message_type=data
events.send_clientmessage_toall()

END
}

function cleanup(){
    if [[ $1 = all ]];then
        if [[ -d $CONFIGDIR ]];then
            rm -rf "$CONFIGDIR"
            echo -e "\n  Deleted $CONFIGDIR"
        fi
        if [[ -d $CONFIGDIR_BKP ]];then
            mv "$CONFIGDIR_BKP" "$CONFIGDIR"
            echo -e "\n  Cancelled\n..Temporary $CONFIGDIR restored\n"
        fi
        rm -f /tmp/blob.*
    elif [[ $1 = save ]];then
        saveSettings
    fi
}

function saveSettings(){
    SHOW=0
    if (( COLS == 0 ));then
        SELECT="FALSE"
    else
        SELECT="TRUE"
    fi
    COLUMNS=(
        "$SELECT" "$PICKOB"
        "$SELECT" "$PICKGTK"
        "$SELECT" "$PICKBG"
        "$SELECT" "$PICKCONKY"
        "$SELECT" "$PICKTINT"
        "$SELECT" "$PICKDMENU"
        #"$SELECT" "$PICKLDM"
        "$SELECT" "$PICKEXIT"
        "$SELECT" "$PICKX"
        )
    # add terminator to array if set as default
    if  readlink -f /usr/bin/x-terminal-emulator | grep terminator &>/dev/null;then
        COLUMNS+=("$SELECT" "$PICKTERM")
    fi
    SLOOP=1
    while (( SLOOP == 1 ));do
        CHOICE=$($DIALOGDEC --list --checklist \
            --title="Choose the configs to save..." \
            --button="Select All:2" \
            $CANCEL $OK \
            --height=340 \
            --column="Select" --column="Config" "${COLUMNS[@]}" \
            2>/dev/null )
            ret=$?
        if (( ret == 1 )); then # cancel button pressed
            COLS=0
            cleanup all
            restoreSettings
        elif (( ret == 2 ));then
            COLS=1
            saveSettings
            SHOW=1
        else
            if [[ ! $CHOICE ]] ; then # entry field is empty, so try again
                RET=$($DIALOG  --image="dialog-question" \
                --text="\n  Make a selection...." \
                $EXIT $OK \
                --width=300 \
                2>/dev/null )
                if (( $? == 1 ));then
                    cleanup all
                fi
            else
                i=0
                retChoice=()
                OIFS=$IFS # save Internal Field Separator
                IFS=$"|" # separator is "|" in returned choices
                # dialog return is in format 'TRUE|value|\nTRUE|value'
                for ret in $CHOICE; do
                    if [[ $ret = *TRUE* ]] &>/dev/null;then
                        continue
                    fi
                    retChoice[$i]="$ret"
                    i=$((i+1))
                done
                IFS=$OIFS # reset IFS back to default
                for item in "${retChoice[@]}";do
                    case "$item" in
                        "$PICKOB"   )   getOBtheme
                                        ;;
                        "$PICKGTK"  )   getGTKtheme
                                        ;;
                        "$PICKBG"   )   getBg
                                        ;;
                        "$PICKCONKY")   getConky
                                        ;;
                        "$PICKTINT" )   getTint
                                        ;;
                        "$PICKDMENU")   getDmenu
                                        ;;
                        "$PICKLDM"  )   getLightdm
                                        ;;
                        "$PICKEXIT" )   getBLexitrc
                                        ;;
                        "$PICKTERM" )   getTerminator
                                        ;;
                        "$PICKX"    )   getXconfig
                                        ;;
                        *           )   echo -e "\n  Unknown value!" 2>&1
                                        exit 1
                                        ;;
                    esac
                done
                SLOOP=0
            fi
        fi
    done
    if (( SHOW == 0 ));then
        COLS=0      # reset columns unselected
        TXT="<big><b><u>Openbox Configurations to be saved:</u></b></big>\n\n"
        TXT2=$(cat "$LISTMSG")
        $DIALOG --text="$TXT$TXT2"
        ret=$?
        if (( ret == 1 ));then
            cleanup all
            restoreSettings
        else
            echo "$ANS" > "$CURSESSION"     # replace entry in saved config flag file
        fi
    fi
}

# $SET from getSet()
function ViewRestoreDialog(){   # list saved theme collections for yad as DLGLIST
    getSet                      # get name of latest set BLOB config
    if (( NUMDIRS == 0 ));then  # no saved configs; go back to Intro dialog
        Intro
    fi
    local themename
    declare -a setARR=()
    declare -a namesARR=()
    declare -a thumbsARR=()
    declare -A uniqnames # hide duplicate directories
    DLGLIST=""
    i=0
    for dir in "$CONFIGPATH"/* "$SYSCONFIGPATH"/* ;do
        if [[ -d $dir ]];then
            if [[ -e $dir/settings.cfg ]];then
                themename="${dir##*/}" # strip path
                themename=${themename// /_}   # replace any spaces in dir name
                [[ "${uniqnames["$themename"]}" = 'found' ]] && continue
                uniqnames["$themename"]='found'
                namesARR[$i]="<big>$themename</big>" # add theme collection name to array
                # get name of current session, set icon for TRUE/FALSE
                if [[ $SET = "$themename" ]];then
                    setARR[$i]="gtk-yes"
                elif [[ "$dir" = "$SYSCONFIGPATH"/* ]]; then
                    setARR[$i]="system"
                else
                    setARR[$i]="gtk-home"
                fi
                IMGTHUMB="None"     # placeholder if no thumbnail found
                f="$dir/$themename-thumb.jpg"
                if [[ $f ]];then
                    IMGTHUMB="$f"
                fi
                thumbsARR[$i]="$IMGTHUMB"
            fi
            i=$((i+1))
        fi
    done
    for ((j=0; j<${#namesARR[*]}; j++));do
        DLGLIST="$DLGLIST ${setARR[j]} ${namesARR[j]} ${thumbsARR[j]}"
    done
}

function restoreSettings(){
    ViewRestoreDialog # generates DLGLIST
    local FPATH=''
    local SETCFG=''
    while true ;do
        CONFIG=$($DIALOGDEC --list --title="$TITLE" \
            --text="Double-click selection, or \"Enter\", or use the \"Restore\" button to restore settings\n" \
            --separator=" " \
            --button="About:5" \
            --button="View image:4" --button="Add New:3" \
            --button="Delete:2" --button="Restore:0" --button="gtk-quit:1" \
            --always-print-result \
            --width=$W --height=$H --center --image-preview \
            --expand-column=3 \
            --column="Last Set:IMG" \
            --column="Config Name":TEXT \
            --column="Screenshot":IMG \
            $DLGLIST \
            2>/dev/null )
        RET=$?
        if [[ $CONFIG =~ '<big>'(.+)'</big>' ]];then
            DIR=${BASH_REMATCH[1]}
             # If same name found, user directory will take precedence.
            if [[ -d "$CONFIGPATH/$DIR" ]]
            then
                FPATH="$CONFIGPATH/$DIR"
            elif [[ -d "$SYSCONFIGPATH/$DIR" ]]
            then
                FPATH="$SYSCONFIGPATH/$DIR"
            fi
        fi
        case $RET in
            0)  SAVED="$FPATH/LISTMSG.txt"
                TEXT="Restoring Configs saved as $CONFIG\n\n"
                TEXT="$TEXT$(< "$SAVED")"
                $DIALOG "$T$TEXT" "$CANCEL" "$OK" 2>/dev/null
                if (( $? == 0 ));then
                    echo "$DIR" > "$CURSESSION"
                    break
                fi
                ;;
            1)  exit 0
                ;;
            2)  if [[ ! $CONFIG ]];then
                    $DIALOG --text="Make a selection before trying to delete" "$EXIT" "$OK" 2>/dev/null
                    if (( $? == 0 ));then
                        continue
                    else
                        exit 0
                    fi
                fi

                SYSDIRTXT="Sorry, system preset theme <b>${DIR}</b> cannot be deleted"
                if [[ "${FPATH%/*}" = "$SYSCONFIGPATH" ]]
                then
                    $DIALOG --image="dialog-warning" "$T$SYSDIRTXT" "$CLOSE" 2>/dev/null
                    continue
                fi

                TEXT="Delete saved configurations <b>$FPATH</b>\nand screenshot?"
                $DIALOG "$T$TEXT" "$CANCEL" "$OK" 2>/dev/null

                if (( $? == 0 ));then
                    rm -rf "$FPATH"
                    rm "$FPATH.jpg"
                    echo -e "\n$DIR DELETED"
                    currentsession=$(cat "$CURSESSION")
                    fpath=$(basename "$FPATH")
                    if [[ $currentsession = "$fpath" ]];then
                        echo "" > "$CURSESSION"
                    fi
                    restoreSettings
                else
                    continue
                fi
                ;;
            3)  setName
                saveSettings
                getScrot
                $DIALOG --text="Settings were saved as <b>$ANS</b>" --image="gtk-save" "$OK" 2>/dev/null
                if [[ -d $CONFIGDIR_BKP ]];then
                    rm -rf "$CONFIGDIR_BKP"
                    echo -e "\n  Temporary $CONFIGDIR deleted\n"
                fi
                restoreSettings
                ;;
            4)  # show screenshot in image viewer
                SEL=$(echo "$CONFIG" | awk -F'[>|<]' '{print $3}' )
                if [[ $SEL ]];then
                    #img="$CONFIGPATH/$SEL.jpg"
                    img="${FPATH%/*}/$SEL.jpg"
                    $IMGCMD "$img"
                else
                    $DIALOG --text="Make a selection" 2>/dev/null
                fi
                restoreSettings
                ;;
            5)  Intro
                ;;
            *)  if (( RET == 252 ));then
                    echo -e "\n  Exited with \"ESC\" key"
                else
                    echo -e "\n  Error= $RET" 2>&1
                fi
                exit 1
                ;;
        esac
    done
    SETCFG="$FPATH/settings.cfg"
    NOW=$(date +"%Y%m%d-%H%M%S") # global: restore functions will inherit
    # get chosen saved configs and restore them
    # kill conkys and tint2s, in case saved config doesn't include them
    if [[ $(pidof conky) ]];then
        killall conky
    fi
    if [[ $(pidof tint2) ]];then
        killall tint2
    fi
    while read -r TAG VAL; do #line;do
        home_marker='%USERHOME%'
        case "$TAG" in
            "[TINT2]"       )   if [[ $VAL ]];then
                                    VAL="${VAL//"$home_marker"/"$HOME"}"
                                    restoreTint2 "$VAL"
                                fi
                                ;;
            "[CONKY]"       )   if [[ $VAL ]];then
                                    VAL="${VAL//"$home_marker"/"$HOME"}"
                                    restoreConky "$VAL"
                                fi
                                ;;
            "[ICONS]"       )   if [[ $VAL ]];then
                                    checkICONS "$VAL"
                                fi
                                ;;
            "[GTK]"         )   if [[ $VAL ]];then
                                    checkGTK "$VAL"
                                fi
                                restoreGTK "$FPATH"
                                reloadGTK
                                ;;
            "[OBTHEME]"     )   if [[ $VAL ]];then
                                    checkOBTHEME "$VAL"
                                fi
                                restoreOBrc "$FPATH"
                                ;;
            "[BACKGROUND]"  )   if [[ $VAL = FEH ]];then
                                    cp "$FPATH/.fehbg" "$HOME"
                                    source "$HOME/.fehbg"
                                else
                                    cp "$FPATH/bg-saved.cfg" "$NITRODIR"
                                    nitrogen --restore
                                fi
                                ;;
            "[DMENU]"       )   restoreDmenu "$FPATH/$DMENU"
                                ;;
            "[LIGHTDM]"     )   echo "Lightdm settings not supported at this time" #restoreLightdm "$FPATH/$LDM"
                                ;;
            "[EXITRC]"      )   restoreBLexitrc "$FPATH"
                                ;;
            "[XFILES]"      )   echo ".bashrc will not be overwritten: a copy is in $FPATH/.bashrc"; restoreXsettings "$FPATH/.Xresources" #"$FPATH/.bashrc" # do not restore .bashrc for now
                                ;;
            "[TERMINATOR]"  )   restoreTerminator "$FPATH/config"
                                ;;
            *               )   echo -e "  Unknown value!" 2>&1
                                restoreSettings
                                ;;
        esac
    done < "$SETCFG"
    openbox --reconfigure
    restoreSettings
}

### END FUNCTIONS ######################################################

# test for blobthemes config directory, create if it doesn't exist
mkdir -p "$CONFIGPATH"

# create file to hold most recent saved configuration name
if [[ ! -f $CURSESSION ]] &>/dev/null;then
    touch "$CURSESSION"
fi

getActiveMonitorDimensions

Intro

exit 0
